{"./":{"url":"./","title":"Introduction","keywords":"","body":" Sequelize Sequelize is a promise-based ORM for Node.js and io.js. It supports the dialects PostgreSQL, MySQL, MariaDB, SQLite and MSSQL and features solid transaction support, relations, read replication and more. Installation Example usage var Sequelize = require('sequelize'); var sequelize = new Sequelize('database', 'username', 'password'); var User = sequelize.define('user', { username: Sequelize.STRING, birthday: Sequelize.DATE }); sequelize.sync().then(function() { return User.create({ username: 'janedoe', birthday: new Date(1980, 6, 20) }); }).then(function(jane) { console.log(jane.get({ plain: true })); }); "},"docs/getting-started.html":{"url":"docs/getting-started.html","title":"Getting started","keywords":"","body":"Installation Sequelize is available via NPM. $ npm install --save sequelize # And one of the following: $ npm install --save pg pg-hstore $ npm install --save mysql // For both mysql and mariadb dialects $ npm install --save sqlite3 $ npm install --save tedious // MSSQL Setting up a connection Sequelize will setup a connection pool on initialization so you should ideally only ever create one instance per database. var sequelize = new Sequelize('database', 'username', 'password', { host: 'localhost', dialect: 'mysql'|'mariadb'|'sqlite'|'postgres'|'mssql', pool: { max: 5, min: 0, idle: 10000 }, // SQLite only storage: 'path/to/database.sqlite' }); // Or you can simply use a connection uri var sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname'); The Sequelize constructor takes a whole slew of options that are available via the API reference. Your first model Models are defined with sequelize.define('name', {attributes}, {options}). var User = sequelize.define('user', { firstName: { type: Sequelize.STRING, field: 'first_name' // Will result in an attribute that is firstName when user facing but first_name in the database }, lastName: { type: Sequelize.STRING } }, { freezeTableName: true // Model tableName will be the same as the model name }); User.sync({force: true}).then(function () { // Table created return User.create({ firstName: 'John', lastName: 'Hancock' }); }); Many more options can be found in the Model API reference Application wide model options The Sequelize constructor takes a define option which will be used as the default options for all defined models. var sequelize = new Sequelize('connectionUri', { define: { timestamps: false // true by default } }); var User = sequelize.define('user', {}); // timestamps is false by default var Post = sequelize.define('post', {}, { timestamps: true // timestamps will now be true }); Promises Sequelize uses promises to control async control-flow. If you are unfamiliar with how promises work, now might be a good time to brush up on them, here and here Basically a promise represents a value which will be present at some point - \"I promise you I will give you a result or an error at some point\". This means that // DON'T DO THIS user = User.findOne() console.log(user.get('firstName')); will never work! This is because user is a promise object, not a data row from the DB. The right way to do it is: User.findOne().then(function (user) { console.log(user.get('firstName')); }); Once you've got the hang of what promises are and how they work, use the bluebird API reference as your go to tool. In particular, you'll probably be using .all a lot. "},"docs/schema.html":{"url":"docs/schema.html","title":"Working with table schemas","keywords":"","body":"Syncing sequelize.sync() will, based on your model definitions, create any missing tables. If force: true it will first drop tables before recreating them. Migrations / Manual schema changes Sequelize has a sister library for handling execution and logging of migration tasks. Sequelize provides a list of ways to programmatically create or change a table schema. createTable addColumn changeColumn removeColumn addIndex removeIndex addConstraint removeConstraint "},"docs/models-definition.html":{"url":"docs/models-definition.html","title":"Definition","keywords":"","body":"Definition To define mappings between a model and a table, use the define method. Sequelize will then automatically add the attributes createdAt and updatedAt to it. So you will be able to know when the database entry went into the db and when it was updated the last time. If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to configuration to see how to do that. var Project = sequelize.define('project', { title: Sequelize.STRING, description: Sequelize.TEXT }) var Task = sequelize.define('task', { title: Sequelize.STRING, description: Sequelize.TEXT, deadline: Sequelize.DATE }) You can also set some options on each column: var Foo = sequelize.define('foo', { // instantiating will automatically set the flag to true if not set flag: { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true}, // default values for dates => current time myDate: { type: Sequelize.DATE, defaultValue: Sequelize.NOW }, // setting allowNull to false will add NOT NULL to the column, which means an error will be // thrown from the DB when the query is executed if the column is null. If you want to check that a value // is not null before querying the DB, look at the validations section below. title: { type: Sequelize.STRING, allowNull: false}, // Creating two objects with the same value will throw an error. The unique property can be either a // boolean, or a string. If you provide the same string for multiple columns, they will form a // composite unique key. someUnique: {type: Sequelize.STRING, unique: true}, uniqueOne: { type: Sequelize.STRING, unique: 'compositeIndex'}, uniqueTwo: { type: Sequelize.INTEGER, unique: 'compositeIndex'} // The unique property is simply a shorthand to create a unique index. someUnique: {type: Sequelize.STRING, unique: true} // It's exactly the same as creating the index in the model's options. {someUnique: {type: Sequelize.STRING}}, {indexes: [{unique: true, fields: ['someUnique']}]} // Go on reading for further information about primary keys identifier: { type: Sequelize.STRING, primaryKey: true}, // autoIncrement can be used to create auto_incrementing integer columns incrementMe: { type: Sequelize.INTEGER, autoIncrement: true }, // Comments can be specified for each field for MySQL and PG hasComment: { type: Sequelize.INTEGER, comment: \"I'm a comment!\" }, // You can specify a custom field name via the \"field\" attribute: fieldWithUnderscores: { type: Sequelize.STRING, field: \"field_with_underscores\" }, // It is possible to create foreign keys: bar_id: { type: Sequelize.INTEGER, references: { // This is a reference to another model model: Bar, // This is the column name of the referenced model key: 'id', // This declares when to check the foreign key constraint. PostgreSQL only. deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE } } }) The comment option can also be used on a table, see model configuration Data types Below are some of the datatypes supported by sequelize. For a full and updated list, see DataTypes. Sequelize.STRING // VARCHAR(255) Sequelize.STRING(1234) // VARCHAR(1234) Sequelize.STRING.BINARY // VARCHAR BINARY Sequelize.TEXT // TEXT Sequelize.TEXT('tiny') // TINYTEXT Sequelize.INTEGER // INTEGER Sequelize.BIGINT // BIGINT Sequelize.BIGINT(11) // BIGINT(11) Sequelize.FLOAT // FLOAT Sequelize.FLOAT(11) // FLOAT(11) Sequelize.FLOAT(11, 12) // FLOAT(11,12) Sequelize.REAL // REAL PostgreSQL only. Sequelize.REAL(11) // REAL(11) PostgreSQL only. Sequelize.REAL(11, 12) // REAL(11,12) PostgreSQL only. Sequelize.DOUBLE // DOUBLE Sequelize.DOUBLE(11) // DOUBLE(11) Sequelize.DOUBLE(11, 12) // DOUBLE(11,12) Sequelize.DECIMAL // DECIMAL Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) Sequelize.DATE // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres Sequelize.DATE(6) // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision Sequelize.DATEONLY // DATE without time. Sequelize.BOOLEAN // TINYINT(1) Sequelize.ENUM('value 1', 'value 2') // An ENUM with allowed values 'value 1' and 'value 2' Sequelize.ARRAY(Sequelize.TEXT) // Defines an array. PostgreSQL only. Sequelize.JSON // JSON column. PostgreSQL only. Sequelize.JSONB // JSONB column. PostgreSQL only. Sequelize.BLOB // BLOB (bytea for PostgreSQL) Sequelize.BLOB('tiny') // TINYBLOB (bytea for PostgreSQL. Other options are medium and long) Sequelize.UUID // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically) Sequelize.RANGE(Sequelize.INTEGER) // Defines int4range range. PostgreSQL only. Sequelize.RANGE(Sequelize.BIGINT) // Defined int8range range. PostgreSQL only. Sequelize.RANGE(Sequelize.DATE) // Defines tstzrange range. PostgreSQL only. Sequelize.RANGE(Sequelize.DATEONLY) // Defines daterange range. PostgreSQL only. Sequelize.RANGE(Sequelize.DECIMAL) // Defines numrange range. PostgreSQL only. Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // Defines array of tstzrange ranges. PostgreSQL only. Sequelize.GEOMETRY // Spatial column. PostgreSQL (with PostGIS) or MySQL only. Sequelize.GEOMETRY('POINT') // Spatial column with geometry type. PostgreSQL (with PostGIS) or MySQL only. Sequelize.GEOMETRY('POINT', 4326) // Spatial column with geometry type and SRID. PostgreSQL (with PostGIS) or MySQL only. The BLOB data type allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column. that data will always be returned as a buffer. If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser: require('pg').types.setTypeParser(1114, function(stringValue) { return new Date(stringValue + \"+0000\"); // e.g., UTC offset. Use any offset that you would like. }); In addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order: Be aware that this does not apply for PostgreSQL! Sequelize.INTEGER.UNSIGNED // INTEGER UNSIGNED Sequelize.INTEGER(11).UNSIGNED // INTEGER(11) UNSIGNED Sequelize.INTEGER(11).ZEROFILL // INTEGER(11) ZEROFILL Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL The examples above only show integer, but the same can be done with bigint and float Usage in object notation: // for enums: sequelize.define('model', { states: { type: Sequelize.ENUM, values: ['active', 'pending', 'deleted'] } }) Deferrable When you specify a foreign key column it is optionally possible to declare the deferrable type in PostgreSQL. The following options are available: // Defer all foreign key constraint check to the end of a transaction Sequelize.Deferrable.INITIALLY_DEFERRED // Immediately check the foreign key constraints Sequelize.Deferrable.INITIALLY_IMMEDIATE // Don't defer the checks at all Sequelize.Deferrable.NOT The last option is the default in PostgreSQL and won't allow you to dynamically change the rule in a transaction. See the transaction section for further information. Getters & setters It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties. Getters and Setters can be defined in 2 ways (you can mix and match these 2 approaches): as part of a single property definition as part of a model options N.B: If a getter or setter is defined in both places then the function found in the relevant property definition will always take precedence. Defining as part of a property var Employee = sequelize.define('employee', { name: { type : Sequelize.STRING, allowNull: false, get : function() { var title = this.getDataValue('title'); // 'this' allows you to access attributes of the instance return this.getDataValue('name') + ' (' + title + ')'; }, }, title: { type : Sequelize.STRING, allowNull: false, set : function(val) { this.setDataValue('title', val.toUpperCase()); } } }); Employee .create({ name: 'John Doe', title: 'senior engineer' }) .then(function(employee) { console.log(employee.get('name')); // John Doe (SENIOR ENGINEER) console.log(employee.get('title')); // SENIOR ENGINEER }) Defining as part of the model options Below is an example of defining the getters and setters in the model options. The fullName getter, is an example of how you can define pseudo properties on your models - attributes which are not actually part of your database schema. In fact, pseudo properties can be defined in two ways: using model getters, or by using a column with the VIRTUAL datatype. Virtual datatypes can have validations, while getters for virtual attributes cannot. Note that the this.firstname and this.lastname references in the fullName getter function will trigger a call to the respective getter functions. If you do not want that then use the getDataValue() method to access the raw value (see below). var Foo = sequelize.define('foo', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { getterMethods : { fullName : function() { return this.firstname + ' ' + this.lastname } }, setterMethods : { fullName : function(value) { var names = value.split(' '); this.setDataValue('firstname', names.slice(0, -1).join(' ')); this.setDataValue('lastname', names.slice(-1).join(' ')); }, } }); Helper functions for use inside getter and setter definitions retrieving an underlying property value - always use this.getDataValue() /* a getter for 'title' property */ function() { return this.getDataValue('title'); } setting an underlying property value - always use this.setDataValue() /* a setter for 'title' property */ function(title) { return this.setDataValue('title', title.toString().toLowerCase()); } N.B: It is important to stick to using the setDataValue() and getDataValue() functions (as opposed to accessing the underlying \"data values\" property directly) - doing so protects your custom getters and setters from changes in the underlying model implementations. Validations Model validations, allow you to specify format/content/inheritance validations for each attribute of the model. Validations are automatically run on create, update and save. You can also call validate() to manually validate an instance. The validations are implemented by validator.js. var ValidateMe = sequelize.define('foo', { foo: { type: Sequelize.STRING, validate: { is: [\"^[a-z]+$\",'i'], // will only allow letters is: /^[a-z]+$/i, // same as the previous example using real RegExp not: [\"[a-z]\",'i'], // will not allow letters isEmail: true, // checks for email format (foo@bar.com) isUrl: true, // checks for url format (http://foo.com) isIP: true, // checks for IPv4 (129.89.23.1) or IPv6 format isIPv4: true, // checks for IPv4 (129.89.23.1) isIPv6: true, // checks for IPv6 format isAlpha: true, // will only allow letters isAlphanumeric: true, // will only allow alphanumeric characters, so \"_abc\" will fail isNumeric: true, // will only allow numbers isInt: true, // checks for valid integers isFloat: true, // checks for valid floating point numbers isDecimal: true, // checks for any numbers isLowercase: true, // checks for lowercase isUppercase: true, // checks for uppercase notNull: true, // won't allow null isNull: true, // only allows null notEmpty: true, // don't allow empty strings equals: 'specific value', // only allow a specific value contains: 'foo', // force specific substrings notIn: [['foo', 'bar']], // check the value is not one of these isIn: [['foo', 'bar']], // check the value is one of these notContains: 'bar', // don't allow specific substrings len: [2,10], // only allow values with length between 2 and 10 isUUID: 4, // only allow uuids isDate: true, // only allow date strings isAfter: \"2011-11-05\", // only allow date strings after a specific date isBefore: \"2011-11-05\", // only allow date strings before a specific date max: 23, // only allow values min: 23, // only allow values >= 23 isArray: true, // only allow arrays isCreditCard: true, // check for valid credit card numbers // custom validations are also possible: isEven: function(value) { if(parseInt(value) % 2 != 0) { throw new Error('Only even values are allowed!') // we also are in the model's context here, so this.otherField // would get the value of otherField if it existed } } } } }); Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for isIn, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as [['one', 'two']] as shown above. To use a custom error message instead of that provided by validator.js, use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with isInt: { msg: \"Must be an integer number of pennies\" } or if arguments need to also be passed add anargsproperty: isIn: { args: [['en', 'zh']], msg: \"Must be English or Chinese\" } When using custom validator functions the error message will be whatever message the thrownErrorobject holds. See the validator.js project for more details on the built in validation methods. Hint: You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged. Validators and allowNull If a particular field of a model is set to allow null (with allowNull: true) and that value has been set to null , its validators do not run. This means you can, for instance, have a string field which validates its length to be at least 5 characters, but which also allowsnull. Model validations Validations can also be defined to check the model after the field-specific validators. Using this you could, for example, ensure either neither of latitude and longitude are set or both, and fail if one but not the other is set. Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators. Any error messages collected are put in the validation result object alongside the field validation errors, with keys named after the failed validation method's key in the validate option object. Even though there can only be one error message for each model validation method at any one time, it is presented as a single string error in an array, to maximize consistency with the field errors. An example: var Pub = Sequelize.define('pub', { name: { type: Sequelize.STRING }, address: { type: Sequelize.STRING }, latitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -90, max: 90 } }, longitude: { type: Sequelize.INTEGER, allowNull: true, defaultValue: null, validate: { min: -180, max: 180 } }, }, { validate: { bothCoordsOrNone: function() { if ((this.latitude === null) !== (this.longitude === null)) { throw new Error('Require either both latitude and longitude or neither') } } } }) In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, raging_bullock_arms.validate() might return { 'latitude': ['Invalid number: latitude'], 'bothCoordsOrNone': ['Require either both latitude and longitude or neither'] } Configuration You can also influence the way Sequelize handles your column names: var Bar = sequelize.define('bar', { /* bla */ }, { // don't add the timestamp attributes (updatedAt, createdAt) timestamps: false, // don't delete database entries but set the newly added attribute deletedAt // to the current date (when deletion was done). paranoid will only work if // timestamps are enabled paranoid: true, // don't use camelcase for automatically added attributes but underscore style // so updatedAt will be updated_at underscored: true, // disable the modification of table names; By default, sequelize will automatically // transform all passed model names (first parameter of define) into plural. // if you don't want that, set the following freezeTableName: true, // define the table's name tableName: 'my_very_custom_table_name' }) If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually: var Foo = sequelize.define('foo', { /* bla */ }, { // don't forget to enable timestamps! timestamps: true, // I don't want createdAt createdAt: false, // I want updatedAt to actually be called updateTimestamp updatedAt: 'updateTimestamp' // And deletedAt to be called destroyTime (remember to enable paranoid for this to work) deletedAt: 'destroyTime', paranoid: true }) You can also change the database engine, e.g. to MyISAM. InnoDB is the default. var Person = sequelize.define('person', { /* attributes */ }, { engine: 'MYISAM' }) // or globally var sequelize = new Sequelize(db, user, pw, { define: { engine: 'MYISAM' } }) Finally you can specify a comment for the table in MySQL and PG var Person = sequelize.define('person', { /* attributes */ }, { comment: \"I'm a table comment!\" }) Import You can also store your model definitions in a single file using the import method. The returned object is exactly the same as defined in the imported file's function. Since v1:5.0 of Sequelize the import is cached, so you won't run into troubles when calling the import of a file twice or more often. // in your server file - e.g. app.js var Project = sequelize.import(__dirname + \"/path/to/models/project\") // The model definition is done in /path/to/models/project.js // As you might notice, the DataTypes are the very same as explained above module.exports = function(sequelize, DataTypes) { return sequelize.define(\"project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) } The import method can also accept a callback as an argument. sequelize.import('project', function(sequelize, DataTypes) { return sequelize.define(\"project\", { name: DataTypes.STRING, description: DataTypes.TEXT }) }) Database synchronization When starting a new project you won't have a database structure and using Sequelize you won't need to. Just specify your model structures and let the library do the rest. Currently supported is the creation and deletion of tables: // Create the tables: Project.sync() Task.sync() // Force the creation! Project.sync({force: true}) // this will drop the table first and re-create it afterwards // drop the tables: Project.drop() Task.drop() // event handling: Project.[sync|drop]().then(function() { // ok ... everything is nice! }).catch(function(error) { // oooh, did you enter wrong database credentials? }) Because synchronizing and dropping all of your tables might be a lot of lines to write, you can also let Sequelize do the work for you: // Sync all models that aren't already in the database sequelize.sync() // Force sync all models sequelize.sync({force: true}) // Drop all tables sequelize.drop() // emit handling: sequelize.[sync|drop]().then(function() { // woot woot }).catch(function(error) { // whooops }) Because .sync({ force: true }) is destructive operation, you can use match option as an additional safety check. match option tells sequelize to match a regex against the database name before syncing - a safety check for cases where force: true is used in tests but not live code. // This will run .sync() only if database name ends with '_test' sequelize.sync({ force: true, match: /_test$/ }); Expansion of models Sequelize allows you to pass custom methods to a model and its instances. Just do the following: var Foo = sequelize.define('foo', { /* attributes */}, { classMethods: { method1: function(){ return 'smth' } }, instanceMethods: { method2: function() { return 'foo' } } }) // Example: Foo.method1() Foo.build().method2() Of course you can also access the instance's data and generate virtual getters: var User = sequelize.define('user', { firstname: Sequelize.STRING, lastname: Sequelize.STRING }, { instanceMethods: { getFullname: function() { return [this.firstname, this.lastname].join(' ') } } }) // Example: User.build({ firstname: 'foo', lastname: 'bar' }).getFullname() // 'foo bar' You can also set custom methods to all of your models during the instantiation: var sequelize = new Sequelize('database', 'username', 'password', { // Other options during the initialization could be here define: { classMethods: { method1: function() {}, method2: function() {} }, instanceMethods: { method3: function() {} } } }) // Example: var Foo = sequelize.define('foo', { /* attributes */}); Foo.method1() Foo.method2() Foo.build().method3() Indexes Sequelize supports adding indexes to the model definition which will be created during Model.sync() or sequelize.sync. sequelize.define('user', {}, { indexes: [ // Create a unique index on email { unique: true, fields: ['email'] }, // Creates a gin index on data with the jsonb_path_ops operator { fields: ['data'], using: 'gin', operator: 'jsonb_path_ops' }, // By default index name will be [table]_[fields] // Creates a multi column partial index { name: 'public_by_author', fields: ['author', 'status'], where: { status: 'public' } }, // A BTREE index with a ordered field { name: 'title_index', method: 'BTREE', fields: ['author', {attribute: 'title', collate: 'en_US', order: 'DESC', length: 5}] } ] }) "},"docs/models-usage.html":{"url":"docs/models-usage.html","title":"Usage","keywords":"","body":"Data retrieval / Finders Finder methods are intended to query data from the database. They do not return plain objects but instead return model instances. Because finder methods return model instances you can call any model instance member on the result as described in the documentation for instances. In this document we'll explore what finder methods can do: find - Search for one specific element in the database // search for known ids Project.findById(123).then(function(project) { // project will be an instance of Project and stores the content of the table entry // with id 123. if such an entry is not defined you will get null }) // search for attributes Project.findOne({ where: {title: 'aProject'} }).then(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null }) Project.findOne({ where: {title: 'aProject'}, attributes: ['id', ['name', 'title']] }).then(function(project) { // project will be the first entry of the Projects table with the title 'aProject' || null // project.title will contain the name of the project }) findOrCreate - Search for a specific element or create it if not available The method findOrCreate can be used to check if a certain element already exists in the database. If that is the case the method will result in a respective instance. If the element does not yet exist, it will be created. Let's assume we have an empty database with a User model which has a username and a job. User .findOrCreate({where: {username: 'sdepold'}, defaults: {job: 'Technical Lead JavaScript'}}) .spread(function(user, created) { console.log(user.get({ plain: true })) console.log(created) /* { username: 'sdepold', job: 'Technical Lead JavaScript', id: 1, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: true */ }) The code created a new instance. So when we already have an instance ... User .create({ username: 'fnord', job: 'omnomnom' }) .then(function() { User .findOrCreate({where: {username: 'fnord'}, defaults: {job: 'something else'}}) .spread(function(user, created) { console.log(user.get({ plain: true })) console.log(created) /* { username: 'fnord', job: 'omnomnom', id: 2, createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET), updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET) } created: false */ }) }) ... the existing entry will not be changed. See the job of the second user, and the fact that created was false. findAndCountAll - Search for multiple elements in the database, returns both data and total count This is a convenience method that combinesfindAll and count (see below) this is useful when dealing with queries related to pagination where you want to retrieve data with a limit and offset but also need to know the total number of records that match the query: The success handler will always receive an object with two properties: count - an integer, total number records matching the where clause rows - an array of objects, the records matching the where clause, within the limit and offset rangeProject .findAndCountAll({ where: { title: { $like: 'foo%' } }, offset: 10, limit: 2 }) .then(function(result) { console.log(result.count); console.log(result.rows); }); findAndCountAll also supports includes. Only the includes that are marked as required will be added to the count part: Suppose you want to find all users who have a profile attached: User.findAndCountAll({ include: [ { model: Profile, required: true} ], limit: 3 }); Because the include for Profile has required set it will result in an inner join, and only the users who have a profile will be counted. If we remove required from the include, both users with and without profiles will be counted. Adding a where clause to the include automatically makes it required: User.findAndCountAll({ include: [ { model: Profile, where: { active: true }} ], limit: 3 }); The query above will only count users who have an active profile, because required is implicitly set to true when you add a where clause to the include. The options object that you pass to findAndCountAll is the same as for findAll (described below). findAll - Search for multiple elements in the database // find multiple entries Project.findAll().then(function(projects) { // projects will be an array of all Project instances }) // also possible: Project.all().then(function(projects) { // projects will be an array of all Project instances }) // search for specific attributes - hash usage Project.findAll({ where: { name: 'A Project' } }).then(function(projects) { // projects will be an array of Project instances with the specified name }) // search with string replacements Project.findAll({ where: [\"id > ?\", 25] }).then(function(projects) { // projects will be an array of Projects having a greater id than 25 }) // search within a specific range Project.findAll({ where: { id: [1,2,3] } }).then(function(projects) { // projects will be an array of Projects having the id 1, 2 or 3 // this is actually doing an IN query }) Project.findAll({ where: { id: { $and: {a: 5} // AND (a = 5) $or: [{a: 5}, {a: 6}] // (a = 5 OR a = 6) $gt: 6, // id > 6 $gte: 6, // id >= 6 $lt: 10, // id [1, 2] (PG array contains operator) $contained: [1, 2] // Complex filtering / OR / NOT queries It's possible to do complex where queries with multiple levels of nested AND, OR and NOT conditions. In order to do that you can use $or, $and or $not: Project.findOne({ where: { name: 'a project', $or: [ { id: [1,2,3] }, { id: { $gt: 10 } } ] } }) Project.findOne({ where: { name: 'a project', id: { $or: [ [1,2,3], { $gt: 10 } ] } } }) Both pieces of code code will generate the following: SELECT * FROM `Projects` WHERE ( `Projects`.`name` = 'a project' AND (`Projects`.`id` IN (1,2,3) OR `Projects`.`id` > 10) ) LIMIT 1; $not example: Project.findOne({ where: { name: 'a project', $not: [ { id: [1,2,3] }, { array: { $contains: [3,4,5] } } ] } }); Will generate: SELECT * FROM `Projects` WHERE ( `Projects`.`name` = 'a project' AND NOT (`Projects`.`id` IN (1,2,3) OR `Projects`.`array` @> ARRAY[1,2,3]::INTEGER[]) ) LIMIT 1; Manipulating the dataset with limit, offset, order and group To get more relevant data, you can use limit, offset, order and grouping: // limit the results of the query Project.findAll({ limit: 10 }) // step over the first 10 elements Project.findAll({ offset: 10 }) // step over the first 10 elements, and take 2 Project.findAll({ offset: 10, limit: 2 }) The syntax for grouping and ordering are equal, so below it is only explained with a single example for group, and the rest for order. Everything you see below can also be done for group Project.findAll({order: 'title DESC'}) // yields ORDER BY title DESC Project.findAll({group: 'name'}) // yields GROUP BY name Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order/group, this will always be the case. If you want to escape column names, you should provide an array of arguments, even though you only want to order/group by a single column something.findOne({ order: [ 'name', // will return `name` 'username DESC', // will return `username DESC` -- i.e. don't do it! ['username', 'DESC'], // will return `username` DESC sequelize.fn('max', sequelize.col('age')), // will return max(`age`) [sequelize.fn('max', sequelize.col('age')), 'DESC'], // will return max(`age`) DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // will return otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC'] // will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite! [{ raw: 'otherfunction(awesomefunction(`col`))' }, 'DESC'] // This won't be quoted, but direction will be added ] }) To recap, the elements of the order/group array can be the following: String - will be quoted Array - first element will be quoted, second will be appended verbatim Object - Raw will be added verbatim without quoting Everything else is ignored, and if raw is not set, the query will fail Sequelize.fn and Sequelize.col returns functions and quoted cools Raw queries Sometimes you might be expecting a massive dataset that you just want to display, without manipulation. For each row you select, Sequelize creates an instance with functions for update, delete, get associations etc. If you have thousands of rows, this might take some time. If you only need the raw data and don't want to update anything, you can do like this to get the raw data. // Are you expecting a massive dataset from the DB, // and don't want to spend the time building DAOs for each entry? // You can pass an extra query option to get the raw data instead: Project.findAll({ where: { ... }, raw: true }) count - Count the occurrences of elements in the database There is also a method for counting database objects: Project.count().then(function(c) { console.log(\"There are \" + c + \" projects!\") }) Project.count({ where: [\"id > ?\", 25] }).then(function(c) { console.log(\"There are \" + c + \" projects with an id greater than 25.\") }) max - Get the greatest value of a specific attribute within a specific table And here is a method for getting the max value of an attribute:f /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.max('age').then(function(max) { // this will return 40 }) Project.max('age', { where: { age: { lt: 20 } } }).then(function(max) { // will be 10 }) min - Get the least value of a specific attribute within a specific table And here is a method for getting the min value of an attribute: /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.min('age').then(function(min) { // this will return 5 }) Project.min('age', { where: { age: { $gt: 5 } } }).then(function(min) { // will be 10 }) sum - Sum the value of specific attributes In order to calculate the sum over a specific column of a table, you can use the sum method. /* Let's assume 3 person objects with an attribute age. The first one is 10 years old, the second one is 5 years old, the third one is 40 years old. */ Project.sum('age').then(function(sum) { // this will return 55 }) Project.sum('age', { where: { age: { $gt: 5 } } }).then(function(sum) { // will be 50 }) Eager loading When you are retrieving data from the database there is a fair chance that you also want to get associations with the same query - this is called eager loading. The basic idea behind that, is the use of the attribute include when you are calling find or findAll. Lets assume the following setup: var User = sequelize.define('user', { name: Sequelize.STRING }) , Task = sequelize.define('task', { name: Sequelize.STRING }) , Tool = sequelize.define('tool', { name: Sequelize.STRING }) Task.belongsTo(User) User.hasMany(Task) User.hasMany(Tool, { as: 'Instruments' }) sequelize.sync().then(function() { // this is where we continue ... }) OK. So, first of all, let's load all tasks with their associated user. Task.findAll({ include: [ User ] }).then(function(tasks) { console.log(JSON.stringify(tasks)) /* [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"userId\": 1, \"user\": { \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\" } }] */ }) Notice that the accessor (the User property in the resulting instance) is singular because the association is one-to-something. Next thing: Loading of data with many-to-something associations! User.findAll({ include: [ Task ] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"tasks\": [{ \"name\": \"A Task\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:40.000Z\", \"updatedAt\": \"2013-03-20T20:31:40.000Z\", \"userId\": 1 }] }] */ }) Notice that the accessor (the Tasks property in the resulting instance) is plural because the association is many-to-something. If an association is aliased (using the as option), you must specify this alias when including the model. Notice how the user's Tools are aliased as Instruments above. In order to get that right you have to specify the model you want to load, as well as the alias: User.findAll({ include: [{ model: Tool, as: 'Instruments' }] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }] */ }) When eager loading we can also filter the associated model using where. This will return all Users in which the where clause of Tool model matches rows. User.findAll({ include: [{ model: Tool, as: 'Instruments', where: { name: { $like: '%ooth%' } } }] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }], [{ \"name\": \"John Smith\", \"id\": 2, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1 }] }], */ }) When an eager loaded model is filtered using include.where then include.required is implicitly set to true. This means that an inner join is done returning parent models with any matching children. Including everything To include all attributes, you can pass a single object with all: true: User.findAll({ include: [{ all: true }]}); Including soft deleted records In case you want to eager load soft deleted records you can do that by setting include.paranoid to true User.findAll({ include: [{ model: Tool, where: { name: { $like: '%ooth%' } }, paranoid: true // query and loads the soft deleted records }] }); Ordering Eager Loaded Associations In the case of a one-to-many relationship. Company.findAll({ include: [ Division ], order: [ [ Division, 'name' ] ] }); Company.findAll({ include: [ Division ], order: [ [ Division, 'name', 'DESC' ] ] }); Company.findAll({ include: [ { model: Division, as: 'Div' } ], order: [ [ { model: Division, as: 'Div' }, 'name' ] ] }); Company.findAll({ include: [ { model: Division, as: 'Div' } ], order: [ [ { model: Division, as: 'Div' }, 'name', 'DESC' ] ] }); Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, Department, 'name' ] ] }); In the case of many-to-many joins, you are also able to sort by attributes in the through table. Company.findAll({ include: [ { model: Division, include: [ Department ] } ], order: [ [ Division, DepartmentDivision, 'name' ] ] }); Nested eager loading You can use nested eager loading to load all related models of a related model: User.findAll({ include: [ {model: Tool, as: 'Instruments', include: [ {model: Teacher, include: [ /* etc */]} ]} ] }).then(function(users) { console.log(JSON.stringify(users)) /* [{ \"name\": \"John Doe\", \"id\": 1, \"createdAt\": \"2013-03-20T20:31:45.000Z\", \"updatedAt\": \"2013-03-20T20:31:45.000Z\", \"Instruments\": [{ // 1:M and N:M association \"name\": \"Toothpick\", \"id\": 1, \"createdAt\": null, \"updatedAt\": null, \"userId\": 1, \"Teacher\": { // 1:1 association \"name\": \"Jimi Hendrix\" } }] }] */ }) This will produce an outer join. However, a where clause on a related model will create an inner join and return only the instances that have matching sub-models. To return all parent instances, you should add required: false. User.findAll({ include: [{ model: Tool, as: 'Instruments', include: [{ model: Teacher, where: { school: \"Woodstock Music School\" }, required: false }] }] }).then(function(users) { /* ... */ }) The query above will return all users, and all their instruments, but only those teachers associated with Woodstock Music School. Include all also supports nested loading: User.findAll({ include: [{ all: true, nested: true }]}); "},"docs/querying.html":{"url":"docs/querying.html","title":"Querying","keywords":"","body":"Attributes To select only some attributes, you can use the attributes option. Most often, you pass an array: Model.findAll({ attributes: ['foo', 'bar'] }); SELECT foo, bar ... Attributes can be renamed using a nested array: Model.findAll({ attributes: ['foo', ['bar', 'baz']] }); SELECT foo, bar AS baz ... You can use sequelize.fn to do aggregations: Model.findAll({ attributes: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] }); SELECT COUNT(hats) AS no_hats ... When using aggregation function, you must give it an alias to be able to access it from the model. In the example above you can get the number of hats with instance.get('no_hats'). Sometimes it may be tiresome to list all the attributes of the model if you only want to add an aggregation: // This is a tiresome way of getting the number of hats... Model.findAll({ attributes: ['id', 'foo', 'bar', 'baz', 'quz', [sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] }); // This is shorter, and less error prone because it still works if you add / remove attributes Model.findAll({ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] } }); SELECT id, foo, bar, baz, quz, COUNT(hats) AS no_hats ... Similarly, its also possible to remove a selected few attributes: Model.findAll({ attributes: { exclude: ['baz'] } }); SELECT id, foo, bar, quz ... Where Whether you are querying with findAll/find or doing bulk updates/destroys you can pass a where object to filter the query. where generally takes an object from attribute:value pairs, where value can be primitives for equality matches or keyed objects for other operators. It's also possible to generate complex AND/OR conditions by nesting sets of $or and $and. Basics Post.findAll({ where: { authorId: 2 } }); // SELECT * FROM post WHERE authorId = 2 Post.findAll({ where: { authorId: 12, status: 'active' } }); // SELECT * FROM post WHERE authorId = 12 AND status = 'active'; Post.destroy({ where: { status: 'inactive' } }); // DELETE FROM post WHERE status = 'inactive'; Post.update({ updatedAt: null, }, { where: { deletedAt: { $ne: null } } }); // UPDATE post SET updatedAt = null WHERE deletedAt NOT NULL; Post.findAll({ where: sequelize.where(sequelize.fn('char_length', sequelize.col('status')), 6) }); // SELECT * FROM post WHERE char_length(status) = 6; Operators $and: {a: 5} // AND (a = 5) $or: [{a: 5}, {a: 6}] // (a = 5 OR a = 6) $gt: 6, // > 6 $gte: 6, // >= 6 $lt: 10, // [1, 2] (PG array contains operator) $contained: [1, 2] // Combinations { rank: { $or: { $lt: 1000, $eq: null } } } // rank [timestamp] { $or: [ { title: { $like: 'Boat%' } }, { description: { $like: '%boat%' } } ] } // title LIKE 'Boat%' OR description LIKE '%boat%' JSONB JSONB can be queried in three different ways. Nested object { meta: { video: { url: { $ne: null } } } } Nested key { \"meta.audio.length\": { $gt: 20 } } Containment { \"meta\": { $contains: { site: { url: 'http://google.com' } } } } Relations / Associations // Find all projects with a least one task where task.state === project.task Project.findAll({ include: [{ model: Task, where: { state: Sequelize.col('project.state') } }] }) Pagination / Limiting // Fetch 10 instances/rows Project.findAll({ limit: 10 }) // Skip 8 instances/rows Project.findAll({ offset: 8 }) // Skip 5 instances and fetch the 5 after that Project.findAll({ offset: 5, limit: 5 }) Ordering order takes an array of items to order the query by. Generally you will want to use a tuple/array of either attribute, direction or just direction to ensure proper escaping. something.findOne({ order: [ // Will escape username and validate DESC against a list of valid direction parameters ['username', 'DESC'], // Will order by max(age) sequelize.fn('max', sequelize.col('age')), // Will order by max(age) DESC [sequelize.fn('max', sequelize.col('age')), 'DESC'], // Will order by otherfunction(`col1`, 12, 'lalala') DESC [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'], // Will order by name on an associated User [User, 'name', 'DESC'], // Will order by name on an associated User aliased as Friend [{model: User, as: 'Friend'}, 'name', 'DESC'], // Will order by name on a nested associated Company of an associated User [User, Company, 'name', 'DESC'], ] // All the following statements will be treated literally so should be treated with care order: 'convert(user_name using gbk)' order: 'username DESC' order: sequelize.literal('convert(user_name using gbk)') }) "},"docs/scopes.html":{"url":"docs/scopes.html","title":"Scope","keywords":"","body":"Definition Scoping allows you to define commonly used queries that you can easily use later. Scopes can include all the same attributes as regular finders, where, include, limit etc. Scopes are defined in the model definition and can be finder objects, or functions returning finder objects - except for the default scope, which can only be an object: var Project = sequelize.define('project', { // Attributes }, { defaultScope: { where: { active: true } }, scopes: { deleted: { where: { deleted: true } }, activeUsers: { include: [ { model: User, where: { active: true }} ] } random: function () { return { where: { someNumber: Math.random() } } }, accessLevel: function (value) { return { where: { accessLevel: { $gte: value } } } } } }); You can also add scopes after a model has been defined by calling addScope. This is especially useful for scopes with includes, where the model in the include might not be defined at the time the other model is being defined. The default scope is always applied. This means, that with the model definition above, Project.findAll() will create the following query: SELECT * FROM projects WHERE active = true The default scope can be removed by calling .unscoped(), .scope(null), or by invoking another scope: Project.scope('deleted').findAll(); // Removes the default scope SELECT * FROM projects WHERE deleted = true Usage Scopes are applied by calling .scope on the model definition, passing the name of one or more scopes. .scope returns a fully functional model instance with all the regular methods: .findAll, .update, .count, .destroy etc. You can save this model instance and reuse it later: var DeletedProjects = Project.scope('deleted'); DeletedProjects.findAll(); // some time passes // let's look for deleted projects again! DeletedProjects.findAll(); Scopes apply to .find, .findAll, .count, .update and .destroy. Scopes which are functions can be invoked in two ways. If the scope does not take any arguments it can be invoked as normally. If the scope takes arguments, pass an object: Project.scope('random', { method: ['accessLevel', 19]}).findAll(); SELECT * FROM projects WHERE someNumber = 42 AND accessLevel >= 19 Merging Several scopes can be applied simultaneously by passing an array of scopes to .scope, or by passing the scopes as consecutive arguments. // These two are equivalent Project.scope('deleted', 'activeUsers').findAll(); Project.scope(['deleted', 'activeUsers']).findAll(); SELECT * FROM projects INNER JOIN users ON projects.userId = users.id AND users.active = true If you want to apply another scope alongside the default scope, pass the key defaultScope to .scope: Project.scope('defaultScope', 'deleted').findAll(); SELECT * FROM projects WHERE active = true AND deleted = true When invoking several scopes, keys from subsequent scopes will overwrite previous ones (similar to _.assign). Consider two scopes: { scope1: { where: { firstName: 'bob', age: { $gt: 20 } }, limit: 2 }, scope2: { where: { age: { $gt: 30 } }, limit: 10 } } Calling .scope('scope1', 'scope2') will yield the following query WHERE firstName = 'bob' AND age > 30 LIMIT 10 Note how limit and age are overwritten by scope2, while firstName is preserved. limit, offset, order, paranoid, lock and raw are overwritten, while where and include are shallowly merged. This means that identical keys in the where objects, and subsequent includes of the same model will both overwrite each other. The same merge logic applies when passing a find object directly to findAll on a scoped model: Project.scope('deleted').findAll({ where: { firstName: 'john' } }) WHERE deleted = true AND firstName = 'john' Here the deleted scope is merged with the finder. If we were to pass where: { firstName: 'john', deleted: false } to the finder, the deleted scope would be overwritten. Associations Sequelize has two different but related scope concepts in relation to associations. The difference is subtle but important: Association scopes Allow you to specify default attributes when getting and setting associations - useful when implementing polymorphic associations. This scope is only invoked on the association between the two models, when using the get, set, add and create associated model functions Scopes on associated models Allows you to apply default and other scopes when fetching associations, and allows you to pass a scoped model when creating associations. These scopes both apply to regular finds on the model and to find through the association. As an example, consider the models Post and Comment. Comment is associated to several other models (Image, Video etc.) and the association between Comment and other models is polymorphic, which means that Comment stores a commentable column, in addition to the foreign key commentable_id. The polymorphic association can be implemented with an association scope : this.Post.hasMany(this.Comment, { foreignKey: 'commentable_id', scope: { commentable: 'post' } }); When calling post.getComments(), this will automatically add WHERE commentable = 'post'. Similarly, when adding new comments to a post, commentable will automagically be set to 'post'. The association scope is meant to live in the background without the programmer having to worry about it - it cannot be disabled. For a more complete polymorphic example, see Association scopes Consider then, that Post has a default scope which only shows active posts: where: { active: true }. This scope lives on the associated model (Post), and not on the association like the commentable scope did. Just like the default scope is applied when calling Post.findAll(), it is also applied when calling User.getPosts() - this will only return the active posts for that user. To disable the default scope, pass scope: null to the getter: User.getPosts({ scope: null }). Similarly, if you want to apply other scopes, pass an array like you would to .scope: User.getPosts({ scope: ['scope1', 'scope2']}); If you want to create a shortcut method to a scope on an associated model, you can pass the scoped model to the association. Consider a shortcut to get all deleted posts for a user: var Post = sequelize.define('post', attributes, { defaultScope: { where: { active: true } }, scopes: { deleted: { where: { deleted: true } } } }); User.hasMany(Post); // regular getPosts association User.hasMany(Post.scope('deleted'), { as: 'deletedPosts' }); User.getPosts(); // WHERE active = true User.getDeletedPosts(); // WHERE deleted = true "},"docs/instances.html":{"url":"docs/instances.html","title":"instances","keywords":"","body":"Building a non-persistent instance In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the build-method will return an unsaved object, which you explicitly have to save. var project = Project.build({ title: 'my awesome project', description: 'woot woot. this will make me a rich man' }) var task = Task.build({ title: 'specify the project idea', description: 'bla', deadline: new Date() }) Built instances will automatically get default values when they were defined: // first define the model var Task = sequelize.define('task', { title: Sequelize.STRING, rating: { type: Sequelize.STRING, defaultValue: 3 } }) // now instantiate an object var task = Task.build({title: 'very important task'}) task.title // ==> 'very important task' task.rating // ==> 3 To get it stored in the database, use the save-method and catch the events ... if needed: project.save().then(function() { // my nice callback stuff }) task.save().catch(function(error) { // mhhh, wth! }) // you can also build, save and access the object with chaining: Task .build({ title: 'foo', description: 'bar', deadline: new Date() }) .save() .then(function(anotherTask) { // you can now access the currently saved task with the variable anotherTask... nice! }).catch(function(error) { // Ooops, do some error-handling }) Creating persistent instances Besides constructing objects, that needs an explicit save call to get stored in the database, there is also the possibility to do all those steps with one single command. It's called create. Task.create({ title: 'foo', description: 'bar', deadline: new Date() }).then(function(task) { // you can now access the newly created task via the variable task }) It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the User model to set only a username and an address but not an admin flag: User.create({ username: 'barfooz', isAdmin: true }, { fields: [ 'username' ] }).then(function(user) { // let's assume the default of isAdmin is false: console.log(user.get({ plain: true })) // => { username: 'barfooz', isAdmin: false } }) Updating / Saving / Persisting an instance Now lets change some values and save changes to the database... There are two ways to do that: // way 1 task.title = 'a very different title now' task.save().then(function() {}) // way 2 task.update({ title: 'a very different title now' }).then(function() {}) It's also possible to define which attributes should be saved when calling save, by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for update. This is how it looks like: task.title = 'foooo' task.description = 'baaaaaar' task.save({fields: ['title']}).then(function() { // title will now be 'foooo' but description is the very same as before }) // The equivalent call using update looks like this: task.update({ title: 'foooo', description: 'baaaaaar'}, {fields: ['title']}).then(function() { // title will now be 'foooo' but description is the very same as before }) When you call save without changing any attribute, this method will execute nothing; Destroying / Deleting persistent instances Once you created an object and got a reference to it, you can delete it from the database. The relevant method is destroy: Task.create({ title: 'a task' }).then(function(task) { // now you see me... return task.destroy(); }).then(function() { // now i'm gone :) }) If the paranoid options is true, the object will not be deleted, instead the deletedAt column will be set to the current timestamp. To force the deletion, you can pass force: true to the destroy call: task.destroy({ force: true }) Working in bulk (creating, updating and destroying multiple rows at once) In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called Model.bulkCreate Model.update Model.destroy Since you are working with multiple models, the callbacks will not return DAO instances. BulkCreate will return an array of model instances/DAOs, they will however, unlike create, not have the resulting values of autoIncrement attributes.update and destroy will return the number of affected rows. First lets look at bulkCreate User.bulkCreate([ { username: 'barfooz', isAdmin: true }, { username: 'foo', isAdmin: true }, { username: 'bar', isAdmin: false } ]).then(function() { // Notice: There are no arguments here, as of right now you'll have to... return User.findAll(); }).then(function(users) { console.log(users) // ... in order to get the array of user objects }) To update several rows at once: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).then(function() { return Task.update( { status: 'inactive' }, /* set attributes' value */, { where: { subject: 'programming' }} /* where criteria */ ); }).spread(function(affectedCount, affectedRows) { // .update returns two values in an array, therefore we use .spread // Notice that affectedRows will only be defined in dialects which support returning: true // affectedCount will be 2 return Task.findAll(); }).then(function(tasks) { console.log(tasks) // the 'programming' tasks will both have a status of 'inactive' }) And delete them: Task.bulkCreate([ {subject: 'programming', status: 'executing'}, {subject: 'reading', status: 'executing'}, {subject: 'programming', status: 'finished'} ]).then(function() { return Task.destroy({ where: { subject: 'programming' }, truncate: true /* this will ignore where and truncate the table instead */ }); }).then(function(affectedRows) { // affectedRows will be 2 return Task.findAll(); }).then(function(tasks) { console.log(tasks) // no programming, just reading :( }) If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert.bulkCreate()accepts an options object as the second parameter. The object can have a fields parameter, (an array) to let it know which fields you want to build explicitly User.bulkCreate([ { username: 'foo' }, { username: 'bar', admin: true} ], { fields: ['username'] }).then(function() { // nope bar, you can't be admin! }) bulkCreate was originally made to be a mainstream/fast way of inserting records, however, sometimes you want the luxury of being able to insert multiple rows at once without sacrificing model validations even when you explicitly tell Sequelize which columns to sift through. You can do by adding a validate: true property to the options object. var Tasks = sequelize.define('task', { name: { type: Sequelize.STRING, validate: { notNull: { args: true, msg: 'name cannot be null' } } }, code: { type: Sequelize.STRING, validate: { len: [3, 10] } } }) Tasks.bulkCreate([ {name: 'foo', code: '123'}, {code: '1234'}, {name: 'bar', code: '1'} ], { validate: true }).catch(function(errors) { /* console.log(errors) would look like: [ { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } }, { record: ... errors: { name: 'SequelizeValidationError', message: 'Validation error', errors: [Object] } } ] */ }) Values of an instance If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use theget-attribute. Calling it with the option plain = true will only return the values of an instance. Person.create({ name: 'Rambow', firstname: 'John' }).then(function(john) { console.log(john.get({ plain: true })) }) // result: // { name: 'Rambow', // firstname: 'John', // id: 1, // createdAt: Tue, 01 May 2012 19:12:16 GMT, // updatedAt: Tue, 01 May 2012 19:12:16 GMT // } Hint:You can also transform an instance into JSON by using JSON.stringify(instance). This will basically return the very same as values. Reloading instances If you need to get your instance in sync, you can use the methodreload. It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on. Person.findOne({ where: { name: 'john' } }).then(function(person) { person.name = 'jane' console.log(person.name) // 'jane' person.reload().then(function() { console.log(person.name) // 'john' }) }) Incrementing certain values of an instance In order to increment values of an instance without running into concurrency issues, you may use increment. First of all you can define a field and the value you want to add to it. User.findById(1).then(function(user) { return user.increment('my-integer-field', {by: 2}) }).then(/* ... */) Second, you can define multiple fields and the value you want to add to them. User.findById(1).then(function(user) { return user.increment([ 'my-integer-field', 'my-very-other-field' ], {by: 2}) }).then(/* ... */) Third, you can define an object containing fields and its increment values. User.findById(1).then(function(user) { return user.increment({ 'my-integer-field': 2, 'my-very-other-field': 3 }) }).then(/* ... */) Decrementing certain values of an instance In order to decrement values of an instance without running into concurrency issues, you may use decrement. First of all you can define a field and the value you want to add to it. User.findById(1).then(function(user) { return user.decrement('my-integer-field', {by: 2}) }).then(/* ... */) Second, you can define multiple fields and the value you want to add to them. User.findById(1).then(function(user) { return user.decrement([ 'my-integer-field', 'my-very-other-field' ], {by: 2}) }).then(/* ... */) Third, you can define an object containing fields and its decrement values. User.findById(1).then(function(user) { return user.decrement({ 'my-integer-field': 2, 'my-very-other-field': 3 }) }).then(/* ... */) "},"docs/associations.html":{"url":"docs/associations.html","title":"Relations/Associations","keywords":"","body":"This section describes the various association types in sequelize. When calling a method such as User.hasOne(Project), we say that the User model (the model that the function is being invoked on) is the source and the Project model (the model being passed as an argument) is the target. One-To-One associations One-To-One associations are associations between exactly two models connected by a single foreign key. BelongsTo BelongsTo associations are associations where the foreign key for the one-to-one relation exists on the source model. A simple example would be a Player being part of a Team with the foreign key on the player. var Player = this.sequelize.define('player', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); Player.belongsTo(Team); // Will add a teamId attribute to Player to hold the primary key value for Team Foreign keys By default the foreign key for a belongsTo relation will be generated from the target model name and the target primary key name. The default casing is camelCase however if the source model is configured with underscored: true the foreignKey will be snake_case. var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company); // Will add companyId to user var User = this.sequelize.define('user', {/* attributes */}, {underscored: true}) , Company = this.sequelize.define('company', { uuid: { type: Sequelize.UUID, primaryKey: true } }); User.belongsTo(Company); // Will add company_uuid to user In cases where as has been defined it will be used in place of the target model name. var User = this.sequelize.define('user', {/* attributes */}) , UserRole = this.sequelize.define('userRole', {/* attributes */}); User.belongsTo(UserRole, {as: 'role'}); // Adds roleId to user rather than userRoleId In all cases the default foreign key can be overwritten with the foreignKey option. When the foreign key option is used, Sequelize will use it as-is: var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company, {foreignKey: 'fk_company'}); // Adds fk_company to User Target keys The target key is the column on the target model that the foreign key column on the source model points to. By default the target key for a belongsTo relation will be the target model's primary key. To define a custom column, use the targetKey option. var User = this.sequelize.define('user', {/* attributes */}) , Company = this.sequelize.define('company', {/* attributes */}); User.belongsTo(Company, {foreignKey: 'fk_companyname', targetKey: 'name'}); // Adds fk_companyname to User HasOne HasOne associations are associations where the foreign key for the one-to-one relation exists on the target model. var User = sequelize.define('user', {/* ... */}) var Project = sequelize.define('project', {/* ... */}) // One-way associations Project.hasOne(User) /* In this example hasOne will add an attribute projectId to the User model! Furthermore, Project.prototype will gain the methods getUser and setUser according to the first parameter passed to define. If you have underscore style enabled, the added attribute will be project_id instead of projectId. The foreign key will be placed on the users table. You can also define the foreign key, e.g. if you already have an existing database and want to work on it: */ Project.hasOne(User, { foreignKey: 'initiator_id' }) /* Because Sequelize will use the model's name (first parameter of define) for the accessor methods, it is also possible to pass a special option to hasOne: */ Project.hasOne(User, { as: 'Initiator' }) // Now you will get Project#getInitiator and Project#setInitiator // Or let's define some self references var Person = sequelize.define('person', { /* ... */}) Person.hasOne(Person, {as: 'Father'}) // this will add the attribute FatherId to Person // also possible: Person.hasOne(Person, {as: 'Father', foreignKey: 'DadId'}) // this will add the attribute DadId to Person // In both cases you will be able to do: Person#setFather Person#getFather // If you need to join a table twice you can double join the same table Team.hasOne(Game, {as: 'HomeTeam', foreignKey : 'homeTeamId'}); Team.hasOne(Game, {as: 'AwayTeam', foreignKey : 'awayTeamId'}); Game.belongsTo(Team); Even though it is called a HasOne association, for most 1:1 relations you usually want the BelongsTo association since BelongsTo will add the foreignKey on the source where hasOne will add on the target. Difference between HasOne and BelongsTo In Sequelize 1:1 relationship can be set using HasOne and BelongsTo. They are suitable for different scenarios. Lets study this difference using an example. Suppose we have two tables to link Player and Team. Lets define their models. var Player = this.sequelize.define('player', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); When we link two model in Sequelize we can refer them as pairs of source and target models. Like this Having Player as the source and Team as the target Player.belongsTo(Team); //Or Player.hasOne(Team); Having Team as the source and Player as the target Team.belongsTo(Player); //Or Team.hasOne(Player); HasOne and BelongsTo insert the association key in different models from each other. HasOne inserts the association key in target model whereas BelongsTo inserts the association key in the source model. Here is an example demonstrating use cases of BelongsTo and HasOne. var Player = this.sequelize.define('player', {/* attributes */}) , Coach = this.sequelize.define('coach', {/* attributes */}) , Team = this.sequelize.define('team', {/* attributes */}); Suppose our Player model has information about its team as teamId column. Information about each Team's Coach is stored in the Team model as coachId column. These both scenarios requires different kind of 1:1 relation because foreign key relation is present on different models each time. When information about association is present in source model we can use belongsTo. In this case Player is suitable for belongsTo because it has teamId column. Player.belongsTo(Team) // `teamId` will be added on Player / Source model When information about association is present in target model we can use hasOne. In this case Coach is suitable for hasOne because Team model store information about its Coach as coachId field. Coach.hasOne(Team) // `coachId` will be added on Team / Target model One-To-Many associations One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source. var User = sequelize.define('user', {/* ... */}) var Project = sequelize.define('project', {/* ... */}) // OK. Now things get more complicated (not really visible to the user :)). // First let's define a hasMany association Project.hasMany(User, {as: 'Workers'}) This will add the attribute projectId or project_id to User. Instances of Project will get the accessors getWorkers and setWorkers. We could just leave it the way it is and let it be a one-way association. But we want more! Let's define it the other way around by creating a many to many association in the next section: Sometimes you may need to associate records on different columns, you may use sourceKey option: var City = sequelize.define('city', { countryCode: Sequelize.STRING }); var Country = sequelize.define('country', { isoCode: Sequelize.STRING }); // Here we can connect countries and cities base on country code Country.hasMany(City, {foreignKey: 'countryCode', sourceKey: 'isoCode'}); City.belongsTo(Country, {foreignKey: 'countryCode', targetKey: 'isoCode'}); Belongs-To-Many associations Belongs-To-Many associations are used to connect sources with multiple targets. Furthermore the targets can also have connections to multiple sources. Project.belongsToMany(User, {through: 'UserProject'}); User.belongsToMany(Project, {through: 'UserProject'}); This will create a new model called UserProject with the equivalent foreign keys projectId and userId. Whether the attributes are camelcase or not depends on the two models joined by the table (in this case User and Project). Defining through is required. Sequelize would previously attempt to autogenerate names but that would not always lead to the most logical setups. This will add methods getUsers, setUsers, addUser,addUsers to Project, and getProjects, setProjects, addProject, and addProjects to User. Sometimes you may want to rename your models when using them in associations. Let's define users as workers and projects as tasks by using the alias (as) option. We will also manually define the foreign keys to use: User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId' }) Project.belongsToMany(User, { as: 'Workers', through: 'worker_tasks', foreignKey: 'projectId' }) foreignKey will allow you to set source model key in the through relation. otherKey will allow you to set target model key in the through relation. User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId', otherKey: 'projectId'}) Of course you can also define self references with belongsToMany: Person.belongsToMany(Person, { as: 'Children', through: 'PersonChildren' }) // This will create the table PersonChildren which stores the ids of the objects. If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one: User = sequelize.define('user', {}) Project = sequelize.define('project', {}) UserProjects = sequelize.define('userProjects', { status: DataTypes.STRING }) User.belongsToMany(Project, { through: UserProjects }) Project.belongsToMany(User, { through: UserProjects }) To add a new project to a user and set its status, you pass an extra object to the setter, which contains the attributes for the join table user.addProject(project, { status: 'started' }) By default the code above will add projectId and userId to the UserProjects table, and remove any previously defined primary key attribute - the table will be uniquely identified by the combination of the keys of the two tables, and there is no reason to have other PK columns. To enforce a primary key on the UserProjects model you can add it manually. UserProjects = sequelize.define('userProjects', { id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true }, status: DataTypes.STRING }) With Belongs-To-Many you can query based on through relation and select specific attributes. For example using findAll with through User.findAll({ include: [{ model: Project, through: { attributes: ['createdAt', 'startedAt', 'finishedAt'], where: {completed: true} } }] }); Scopes This section concerns association scopes. For a definition of association scopes vs. scopes on associated models, see Scopes. Association scopes allow you to place a scope (a set of default attributes for get and create) on the association. Scopes can be placed both on the associated model (the target of the association), and on the through table for n:m relations. 1:m Assume we have tables Comment, Post and Image. A comment can be associated to either an image or a post via commentable_id and commentable - we say that Post and Image are Commentable this.Comment = this.sequelize.define('comment', { title: Sequelize.STRING, commentable: Sequelize.STRING, commentable_id: Sequelize.INTEGER }, { instanceMethods: { getItem: function() { return this['get' + this.get('commentable').substr(0, 1).toUpperCase() + this.get('commentable').substr(1)](); } } }); this.Post.hasMany(this.Comment, { foreignKey: 'commentable_id', constraints: false, scope: { commentable: 'post' } }); this.Comment.belongsTo(this.Post, { foreignKey: 'commentable_id', constraints: false, as: 'post' }); this.Image.hasMany(this.Comment, { foreignKey: 'commentable_id', constraints: false, scope: { commentable: 'image' } }); this.Comment.belongsTo(this.Image, { foreignKey: 'commentable_id', constraints: false, as: 'image' }); constraints: false, disables references constraints - since the commentable_id column references several tables, we cannot add a REFERENCES constraint to it. Note that the Image -> Comment and Post -> Comment relations define a scope, commentable: 'image' and commentable: 'post' respectively. This scope is automatically applied when using the association functions: image.getComments() SELECT * FROM comments WHERE commentable_id = 42 AND commentable = 'image'; image.createComment({ title: 'Awesome!' }) INSERT INTO comments (title, commentable_id, commentable) VALUES ('Awesome!', 42, 'image'); image.addComment(comment); UPDATE comments SET commentable_id = 42, commentable = 'image' The getItem utility function on Comment completes the picture - it simply converts the commentable string into a call to either getImage or getPost, providing an abstraction over whether a comment belongs to a post or an image. n:m Continuing with the idea of a polymorphic model, consider a tag table - an item can have multiple tags, and a tag can be related to several items. For brevity, the example only shows a Post model, but in reality Tag would be related to several other models. ItemTag = sequelize.define('item_tag', { tag_id: { type: DataTypes.INTEGER, unique: 'item_tag_taggable' }, taggable: { type: DataTypes.STRING, unique: 'item_tag_taggable' }, taggable_id: { type: DataTypes.INTEGER, unique: 'item_tag_taggable', references: null } }); Tag = sequelize.define('tag', { name: DataTypes.STRING }); Post.belongsToMany(Tag, { through: { model: ItemTag, unique: false, scope: { taggable: 'post' } }, foreignKey: 'taggable_id', constraints: false }); Tag.belongsToMany(Post, { through: { model: ItemTag, unique: false }, foreignKey: 'tag_id' }); Notice that the scoped column (taggable) is now on the through model (ItemTag). We could also define a more restrictive association, for example to get all pending tags for a post by applying a scope of both the through model (ItemTag) and the target model (Tag): Post.hasMany(Tag, { through: { model: ItemTag, unique: false, scope: { taggable: 'post' } }, scope: { status: 'pending' }, as: 'pendingTags', foreignKey: 'taggable_id', constraints: false }); Post.getPendingTags(); SELECT `tag`.* INNER JOIN `item_tags` AS `item_tag` ON `tag`.`id` = `item_tag`.`tagId` AND `item_tag`.`taggable_id` = 42 AND `item_tag`.`taggable` = 'post' WHERE (`tag`.`status` = 'pending'); constraints: false disables references constraints on the taggable_id column. Because the column is polymorphic, we cannot say that it REFERENCES a specific table. Naming strategy By default sequelize will use the model name (the name passed to sequelize.define) to figure out the name of the model when used in associations. For example, a model named user will add the functions get/set/add User to instances of the associated model, and a property named .user in eager loading, while a model named User will add the same functions, but a property named .User (notice the upper case U) in eager loading. As we've already seen, you can alias models in associations using as. In single associations (has one and belongs to), the alias should be singular, while for many associations (has many) it should be plural. Sequelize then uses the inflection library to convert the alias to its singular form. However, this might not always work for irregular or non-english words. In this case, you can provide both the plural and the singular form of the alias: User.belongsToMany(Project, { as: { singular: 'task', plural: 'tasks' }}) // Notice that inflection has no problem singularizing tasks, this is just for illustrative purposes. If you know that a model will always use the same alias in associations, you can provide it when creating the model var Project = sequelize.define('project', attributes, { name: { singular: 'task', plural: 'tasks', } }) User.belongsToMany(Project); This will add the functions add/set/get Tasks to user instances. Remember, that using as to change the name of the association will also change the name of the foreign key. When using as, it is safest to also specify the foreign key. Invoice.belongsTo(Subscription) Subscription.hasMany(Invoice) Without as, this adds subscriptionId as expected. However, if you were to say Invoice.belongsTo(Subscription, { as: 'TheSubscription' }), you will have both subscriptionId and theSubscriptionId, because sequelize is not smart enough to figure that the calls are two sides of the same relation. 'foreignKey' fixes this problem; Invoice.belongsTo(Subscription, , { as: 'TheSubscription', foreignKey: 'subscription_id' }) Subscription.hasMany(Invoice, { foreignKey: 'subscription_id' ) Associating objects Because Sequelize is doing a lot of magic, you have to call Sequelize.sync after setting the associations! Doing so will allow you the following: Project.belongsToMany(Task) Task.belongsToMany(Project) Project.create()... Task.create()... Task.create()... // save them... and then: project.setTasks([task1, task2]).then(function() { // saved! }) // ok, now they are saved... how do I get them later on? project.getTasks().then(function(associatedTasks) { // associatedTasks is an array of tasks }) // You can also pass filters to the getter method. // They are equal to the options you can pass to a usual finder method. project.getTasks({ where: 'id > 10' }).then(function(tasks) { // tasks with an id greater than 10 :) }) // You can also only retrieve certain fields of a associated object. project.getTasks({attributes: ['title']}).then(function(tasks) { // retrieve tasks with the attributes \"title\" and \"id\" }) To remove created associations you can just call the set method without a specific id: // remove the association with task1 project.setTasks([task2]).then(function(associatedTasks) { // you will get task2 only }) // remove 'em all project.setTasks([]).then(function(associatedTasks) { // you will get an empty array }) // or remove 'em more directly project.removeTask(task1).then(function() { // it's gone }) // and add 'em again project.addTask(task1).then(function() { // it's back again }) You can of course also do it vice versa: // project is associated with task1 and task2 task2.setProject(null).then(function() { // and it's gone }) For hasOne/belongsTo its basically the same: Task.hasOne(User, {as: \"Author\"}) Task#setAuthor(anAuthor) Adding associations to a relation with a custom join table can be done in two ways (continuing with the associations defined in the previous chapter): // Either by adding a property with the name of the join table model to the object, before creating the association project.UserProjects = { status: 'active' } u.addProject(project) // Or by providing a second argument when adding the association, containing the data that should go in the join table u.addProject(project, { status: 'active' }) // When associating multiple objects, you can combine the two options above. In this case the second argument // will be treated as a defaults object, that will be used if no data is provided project1.UserProjects = { status: 'inactive' } u.setProjects([project1, project2], { status: 'active' }) // The code above will record inactive for project one, and active for project two in the join table When getting data on an association that has a custom join table, the data from the join table will be returned as a DAO instance: u.getProjects().then(function(projects) { var project = projects[0] if (project.UserProjects.status === 'active') { // .. do magic // since this is a real DAO instance, you can save it directly after you are done doing magic return project.UserProjects.save() } }) If you only need some of the attributes from the join table, you can provide an array with the attributes you want: // This will select only name from the Projects table, and only status from the UserProjects table user.getProjects({ attributes: ['name'], joinTableAttributes: ['status']}) Check associations You can also check if an object is already associated with another one (N:M only). Here is how you'd do it: // check if an object is one of associated ones: Project.create({ /* */ }).then(function(project) { return User.create({ /* */ }).then(function(user) { return project.hasUser(user).then(function(result) { // result would be false return project.addUser(user).then(function() { return project.hasUser(user).then(function(result) { // result would be true }) }) }) }) }) // check if all associated objects are as expected: // let's assume we have already a project and two users project.setUsers([user1, user2]).then(function() { return project.hasUsers([user1]); }).then(function(result) { // result would be false return project.hasUsers([user1, user2]); }).then(function(result) { // result would be true }) Foreign Keys When you create associations between your models in sequelize, foreign key references with constraints will automatically be created. The setup below: var Task = this.sequelize.define('task', { title: Sequelize.STRING }) , User = this.sequelize.define('user', { username: Sequelize.STRING }) User.hasMany(Task) Task.belongsTo(User) Will generate the following SQL: CREATE TABLE IF NOT EXISTS `User` ( `id` INTEGER PRIMARY KEY, `username` VARCHAR(255) ); CREATE TABLE IF NOT EXISTS `Task` ( `id` INTEGER PRIMARY KEY, `title` VARCHAR(255), `user_id` INTEGER REFERENCES `User` (`id`) ON DELETE SET NULL ON UPDATE CASCADE ); The relation between task and user injects the user_id foreign key on tasks, and marks it as a reference to the User table. By default user_id will be set to NULL if the referenced user is deleted, and updated if the id of the user id updated. These options can be overridden by passing onUpdate and onDelete options to the association calls. The validation options are RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL. For 1:1 and 1:m associations the default option is SET NULL for deletion, and CASCADE for updates. For n:m, the default for both is CASCADE. This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table referencing that row will also be deleted or updated. Adding constraints between tables means that tables must be created in the database in a certain order, when using sequelize.sync. If Task has a reference to User, the User table must be created before the Task table can be created. This can sometimes lead to circular references, where sequelize cannot find an order in which to sync. Imagine a scenario of documents and versions. A document can have multiple versions, and for convenience, a document has an reference to it's current version. var Document = this.sequelize.define('document', { author: Sequelize.STRING }) , Version = this.sequelize.define('version', { timestamp: Sequelize.DATE }) Document.hasMany(Version) // This adds document_id to version Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id'}) // This adds current_version_id to document However, the code above will result in the following error: Cyclic dependency found. 'Document' is dependent of itself. Dependency Chain: Document -> Version => Document. In order to alleviate that, we can pass constraints: false to one of the associations: Document.hasMany(Version) Document.belongsTo(Version, { as: 'Current', foreignKey: 'current_version_id', constraints: false}) Which will allow us to sync the tables correctly: CREATE TABLE IF NOT EXISTS `Document` ( `id` INTEGER PRIMARY KEY, `author` VARCHAR(255), `current_version_id` INTEGER ); CREATE TABLE IF NOT EXISTS `Version` ( `id` INTEGER PRIMARY KEY, `timestamp` DATETIME, `document_id` INTEGER REFERENCES `Document` (`id`) ON DELETE SET NULL ON UPDATE CASCADE ); Enforcing a foreign key reference without constraints Some times you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them. var Series, Trainer, Video // Series has a trainer_id=Trainer.id foreign reference key after we call Trainer.hasMany(series) Series = sequelize.define('series', { title: DataTypes.STRING, sub_title: DataTypes.STRING, description: DataTypes.TEXT, // Set FK relationship (hasMany) with `Trainer` trainer_id: { type: DataTypes.INTEGER, references: { model: \"trainers\", key: \"id\" } } }) Trainer = sequelize.define('trainer', { first_name: DataTypes.STRING, last_name: DataTypes.STRING }); // Video has a series_id=Series.id foreign reference key after we call Series.hasOne(Video)... Video = sequelize.define('video', { title: DataTypes.STRING, sequence: DataTypes.INTEGER, description: DataTypes.TEXT, // set relationship (hasOne) with `Series` series_id: { type: DataTypes.INTEGER, references: { model: Series, // Can be both a string representing the table name, or a reference to the model key: \"id\" } } }); Series.hasOne(Video); Trainer.hasMany(Series); Creating with associations An instance can be created with nested association in one step, provided all elements are new. Creating elements of a \"BelongsTo\" or \"HasOne\" association Consider the following models: var Product = this.sequelize.define('product', { title: Sequelize.STRING }); var User = this.sequelize.define('user', { first_name: Sequelize.STRING, last_name: Sequelize.STRING }); Product.belongsTo(User); // Also works for `hasOne` A new Product and User can be created in one step in the following way: return Product.create({ title: 'Chair', user: { first_name: 'Mick', last_name: 'Broadstone' } }, { include: [ User ] }); Creating elements of a \"BelongsTo\" association with an alias The previous example can be extended to support an association alias. var Creator = Product.belongsTo(User, {as: 'creator'}); return Product.create({ title: 'Chair', creator: { first_name: 'Matt', last_name: 'Hansen' } }, { include: [ Creator ] }); Creating elements of a \"HasMany\" or \"BelongsToMany\" association Let's introduce the ability to associate a project with many tags. Setting up the models could look like: var Tag = this.sequelize.define('tag', { name: Sequelize.STRING }); Product.hasMany(Tag); // Also works for `belongsToMany`. Now we can create a project with multiple tags in the following way: Product.create({ id: 1, title: 'Chair', tags: [ { name: 'Alpha'}, { name: 'Beta'} ] }, { include: [ Tag ] }) And, we can modify this example to support an alias as well: var Categories = Product.hasMany(Tag, {as: 'categories'}); Product.create({ id: 1, title: 'Chair', categories: [ {id: 1, name: 'Alpha'}, {id: 2, name: 'Beta'} ] }, { include: [{ model: Categories, as: 'categories' }] }) "},"docs/hooks.html":{"url":"docs/hooks.html","title":"Hooks","keywords":"","body":"Hooks (also known as callbacks or lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a beforeUpdate hook. For a full list of hooks, see Hooks API. Order of Operations (1) beforeBulkCreate(instances, options, fn) beforeBulkDestroy(options, fn) beforeBulkUpdate(options, fn) (2) beforeValidate(instance, options, fn) (-) validate (3) afterValidate(instance, options, fn) - or - validationFailed(instance, options, error, fn) (4) beforeCreate(instance, options, fn) beforeDestroy(instance, options, fn) beforeUpdate(instance, options, fn) (-) create destroy update (5) afterCreate(instance, options, fn) afterDestroy(instance, options, fn) afterUpdate(instance, options, fn) (6) afterBulkCreate(instances, options, fn) afterBulkDestroy(options, fn) afterBulkUpdate(options, fn) Declaring Hooks Arguments to hooks are passed by reference. This means, that you can change the values, and this will be reflected in the insert / update statement. A hook may contain async actions - in this case the hook function should return a promise. There are currently three ways to programmatically add hooks: // Method 1 via the .define() method var User = sequelize.define('user', { username: DataTypes.STRING, mood: { type: DataTypes.ENUM, values: ['happy', 'sad', 'neutral'] } }, { hooks: { beforeValidate: function(user, options) { user.mood = 'happy' }, afterValidate: function(user, options) { user.username = 'Toni' } } }) // Method 2 via the .hook() method User.hook('beforeValidate', function(user, options) { user.mood = 'happy' }) User.hook('afterValidate', function(user, options) { return sequelize.Promise.reject(\"I'm afraid I can't let you do that!\") }) // Method 3 via the direct method User.beforeCreate(function(user, options) { return hashPassword(user.password).then(function (hashedPw) { user.password = hashedPw; }); }) User.afterValidate('myHookAfter', function(user, options, fn) { user.username = 'Toni' }) Removing hooks Only a hook with name param can be removed. var Book = sequelize.define('book', { title: DataTypes.STRING }) Book.addHook('afterCreate', 'notifyUsers', function(book, options) { // ... }) Book.removeHook('afterCreate', 'notifyUsers') Global / universal hooks Global hooks are hooks which are run for all models. They can define behaviours that you want for all your models, and are especially useful for plugins. They can be defined in two ways, which have slightly different semantics: Sequelize.options.define (default hook) var sequelize = new Sequelize(..., { define: { hooks: { beforeCreate: function () { // Do stuff } } } }); This adds a default hook to all models, which is run if the model does not define its own beforeCreate hook: var User = sequelize.define('user'); var Project = sequelize.define('project', {}, { hooks: { beforeCreate: function () { // Do other stuff } } }); User.create() // Runs the global hook Project.create() // Runs its own hook (because the global hook is overwritten) Sequelize.addHook (permanent hook) sequelize.addHook('beforeCreate', function () { // Do stuff }); This hooks is always run before create, regardless of whether the model specifies its own beforeCreate hook: var User = sequelize.define('user'); var Project = sequelize.define('project', {}, { hooks: { beforeCreate: function () { // Do other stuff } } }); User.create() // Runs the global hook Project.create() // Runs its own hook, followed by the global hook Local hooks are always run before global hooks. Instance hooks The following hooks will emit whenever you're editing a single object beforeValidate afterValidate or validationFailed beforeCreate / beforeUpdate / beforeDestroy afterCreate / afterUpdate / afterDestroy // ...define ... User.beforeCreate(function(user) { if (user.accessLevel > 10 && user.username !== \"Boss\") { throw new Error(\"You can't grant this user an access level above 10!\") } }) This example will return an error: User.create({username: 'Not a Boss', accessLevel: 20}).catch(function(err) { console.log(err) // You can't grant this user an access level above 10! }) The following example would return successful: User.create({username: 'Boss', accessLevel: 20}).then(function(user) { console.log(user) // user object with username as Boss and accessLevel of 20 }) Model hooks Sometimes you'll be editing more than one record at a time by utilizing the bulkCreate, update, destroy methods on the model. The following will emit whenever you're using one of those methods. beforeBulkCreate / beforeBulkUpdate / beforeBulkDestroy afterBulkCreate / afterBulkUpdate / afterBulkDestroy If you want to emit hooks for each individual record, along with the bulk hooks you can pass individualHooks: true to the call. Model.destroy({ where: {accessLevel: 0}, individualHooks: true}) // Will select all records that are about to be deleted and emit before- + after- Destroy on each instance Model.update({username: 'Toni'}, { where: {accessLevel: 0}, individualHooks: true}) // Will select all records that are about to be updated and emit before- + after- Update on each instance Some model hooks have two or three parameters sent to each hook depending on it's type. Model.beforeBulkCreate(function(records, fields) { // records = the first argument sent to .bulkCreate // fields = the second argument sent to .bulkCreate }) Model.bulkCreate([ {username: 'Toni'}, // part of records argument {username: 'Tobi'} // part of records argument ], ['username'] /* part of fields argument */) Model.beforeBulkUpdate(function(attributes, where) { // attributes = first argument sent to Model.update // where = second argument sent to Model.update }) Model.update({gender: 'Male'} /*attributes argument*/, { where: {username: 'Tom'}} /*where argument*/) Model.beforeBulkDestroy(function(whereClause) { // whereClause = first argument sent to Model.destroy }) Model.destroy({ where: {username: 'Tom'}} /*whereClause argument*/) If you use Model.bulkCreate(...) with the updatesOnDuplicate option, changes made in the hook to fields that aren't given in the updatesOnDuplicate array will not be persisted to the database. However it is possible to change the updatesOnDuplicate option inside the hook if this is what you want. // Bulk updating existing users with updatesOnDuplicate option Users.bulkCreate([{ id: 1, isMemeber: true}, { id: 2, isMember: false}], { updatesOnDuplicate: ['isMember']}) User.beforeBulkCreate(function (users, options) { users.forEach(function (user) { if (user.isMember) { user.memberSince = new Date() } }) // Add memberSince to updatesOnDuplicate otherwise the memberSince date wont be // saved to the database options.updatesOnDuplicate.push('memberSince') }) Associations For the most part hooks will work the same for instances when being associated except a few things When using add/set functions the beforeUpdate/afterUpdate hooks will run. The only way to call beforeDestroy/afterDestroy hooks are on associations with onDelete: 'cascade' and the option hooks: true. For instance: var Projects = sequelize.define('projects', { title: DataTypes.STRING }) var Tasks = sequelize.define('tasks', { title: DataTypes.STRING }) Projects.hasMany(Tasks, { onDelete: 'cascade', hooks: true }) Tasks.belongsTo(Projects) This code will run beforeDestroy/afterDestroy on the Tasks table. Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute a DELETE FROM `table` WHERE associatedIdentifier = associatedIdentifier.primaryKey However, adding hooks: true explicitly tells Sequelize that optimization is not of your concern and will perform a SELECT on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters. If your association is of type n:m, you may be interested in firing hooks on the through model when using the remove call. Internally, sequelize is using Model.destroy resulting in calling the bulkDestroy instead of the before/afterDestroy hooks on each through instance. This can be simply solved by passing {individualHooks: true} to the remove call, resulting on each hook to be called on each removed through instance object. A Note About Transactions Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction is specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet: // Here we use the promise-style of async hooks rather than // the callback. User.hook('afterCreate', function(user, options) { // 'transaction' will be available in options.transaction // This operation will be part of the same transaction as the // original User.create call. return User.update({ mood: 'sad' }, { where: { id: user.id }, transaction: options.transaction }); }); sequelize.transaction(function(t) { User.create({ username: 'someguy', mood: 'happy', transaction: t }); }); If we had not included the transaction option in our call to User.update in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed. Internal Transactions It is very important to recognize that sequelize may make use of transactions internally for certain operations such as Model.findOrCreate. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify { transaction: options.transaction }. If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified { transaction: null } and can expect the default behaviour. "},"docs/transactions.html":{"url":"docs/transactions.html","title":"Transactions","keywords":"","body":"Sequelize supports two ways of using transactions: One which will automatically commit or rollback the transaction based on the result of a promise chain and, (if enabled) pass the transaction to all calls within the callback And one which leaves committing, rolling back and passing the transaction to the user. The key difference is that the managed transaction uses a callback that expects a promise to be returned to it while the unmanaged transaction returns a promise. Managed transaction (auto-callback) Managed transactions handle committing or rolling back the transaction automagically. You start a managed transaction by passing a callback to sequelize.transaction. Notice how the callback passed to transaction returns a promise chain, and does not explicitly call t.commit() nor t.rollback(). If all promises in the returned chain are resolved successfully the transaction is committed. If one or several of the promises are rejected, the transaction is rolled back. return sequelize.transaction(function (t) { // chain all your queries here. make sure you return them. return User.create({ firstName: 'Abraham', lastName: 'Lincoln' }, {transaction: t}).then(function (user) { return user.setShooter({ firstName: 'John', lastName: 'Boothe' }, {transaction: t}); }); }).then(function (result) { // Transaction has been committed // result is whatever the result of the promise chain returned to the transaction callback }).catch(function (err) { // Transaction has been rolled back // err is whatever rejected the promise chain returned to the transaction callback }); Throw errors to rollback When using the managed transaction you should never commit or rollback the transaction manually. If all queries are successful, but you still want to rollback the transaction (for example because of a validation failure) you should throw an error to break and reject the chain: return sequelize.transaction(function (t) { return User.create({ firstName: 'Abraham', lastName: 'Lincoln' }, {transaction: t}).then(function (user) { // Woops, the query was successful but we still want to roll back! throw new Error(); }); }); Automatically pass transactions to all queries In the examples above, the transaction is still manually passed, by passing { transaction: t } as the second argument. To automatically pass the transaction to all queries you must install the continuation local storage (CLS) module and instantiate a namespace in your own code: var cls = require('continuation-local-storage'), namespace = cls.createNamespace('my-very-own-namespace'); To enable CLS you must tell sequelize which namespace to use by setting it as a property on the sequelize constructor: var Sequelize = require('sequelize'); Sequelize.cls = namespace; new Sequelize(....); Notice, that the cls property must be set on the constructor, not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances. CLS works like a thread-local storage for callbacks. What this means in practice is, that different callback chains can access local variables by using the CLS namespace. When CLS is enabled sequelize will set the transaction property on the namespace when a new transaction is created. Since variables set within a callback chain are private to that chain several concurrent transactions can exist at the same time: sequelize.transaction(function (t1) { namespace.get('transaction') === t1; // true }); sequelize.transaction(function (t2) { namespace.get('transaction') === t2; // true }); In most case you won't need to access namespace.get('transaction') directly, since all queries will automatically look for a transaction on the namespace: sequelize.transaction(function (t1) { // With CLS enabled, the user will be created inside the transaction return User.create({ name: 'Alice' }); }); Concurrent/Partial transactions You can have concurrent transactions within a sequence of queries or have some of them excluded from any transactions. Use the {transaction: } option to control which transaction a query belong to: Without CLS enabled sequelize.transaction(function (t1) { return sequelize.transaction(function (t2) { // With CLS enable, queries here will by default use t2 // Pass in the `transaction` option to define/alter the transaction they belong to. return Promise.all([ User.create({ name: 'Bob' }, { transaction: null }), User.create({ name: 'Mallory' }, { transaction: t1 }), User.create({ name: 'John' }) // this would default to t2 ]); }); }); Isolation levels The possible isolations levels to use when starting a transaction: Sequelize.Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // \"READ UNCOMMITTED\" Sequelize.Transaction.ISOLATION_LEVELS.READ_COMMITTED // \"READ COMMITTED\" Sequelize.Transaction.ISOLATION_LEVELS.REPEATABLE_READ // \"REPEATABLE READ\" Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE // \"SERIALIZABLE\" By default, sequelize uses \"REPEATABLE READ\". If you want to use a different isolation level, pass in the desired level as the first argument: return sequelize.transaction({ isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }, function (t) { // your transactions }); Unmanaged transaction (then-callback) Unmanaged transactions force you to manually rollback or commit the transaction. If you don't do that, the transaction will hang until it times out. To start an unmanaged transaction, call sequelize.transaction() without a callback (you can still pass an options object) and call then on the returned promise. Notice that commit() and rollback() returns a promise. return sequelize.transaction().then(function (t) { return User.create({ firstName: 'Homer', lastName: 'Simpson' }, {transaction: t}).then(function (user) { return user.addSibling({ firstName: 'Lisa', lastName: 'Simpson' }, {transaction: t}); }).then(function () { return t.commit(); }).catch(function (err) { return t.rollback(); }); }); Options The transaction method can be called with an options object as the first argument, that allows the configuration of the transaction. return sequelize.transaction({ /* options */ }); The following options (with it's default values) are available: { autocommit: true, isolationLevel: 'REPEATABLE_READ', deferrable: 'NOT DEFERRABLE' // implicit default of postgres } The isolationLevel can either be set globally when initializing the Sequelize instance or locally for every transaction: // globally new Sequelize('db', 'user', 'pw', { isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }); // locally sequelize.transaction({ isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE }); The deferrable option triggers an additional query after the transaction start that optionally set the constraint checks to be deferred or immediate. Please note that this is only supported in PostgreSQL. sequelize.transaction({ // to defer all constraints: deferrable: Sequelize.Deferrable.SET_DEFERRED, // to defer a specific constraint: deferrable: Sequelize.Deferrable.SET_DEFERRED(['some_constraint']), // to not defer constraints: deferrable: Sequelize.Deferrable.SET_IMMEDIATE }) Usage with other sequelize methods The transaction option goes with most other options, which are usually the first argument of a method. For methods that take values, like .create, .update(), .updateAttributes() etc. transaction should be passed to the option in the second argument. If unsure, refer to the API documentation for the method you are using to be sure of the signature. "},"docs/legacy.html":{"url":"docs/legacy.html","title":"Working with legacy tables","keywords":"","body":"While out of the box Sequelize will seem a bit opinionated it's trivial to both legacy and forward proof your application by defining (otherwise generated) table and field names. Tables sequelize.define('user', { }, { tableName: 'users' }); Fields sequelize.define('modelName', { userId: { type: Sequelize.INTEGER, field: 'user_id' } }); Primary keys Sequelize will assume your table has a id primary key property by default. To define your own primary key: sequelize.define('collection', { uid: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true // Automatically gets converted to SERIAL for postgres } }); sequelize.define('collection', { uuid: { type: Sequelize.UUID, primaryKey: true } }); And if your model has no primary key at all you can use Model.removeAttribute('id'); Foreign keys // 1:1 Organization.belongsTo(User, {foreignKey: 'owner_id'}); User.hasOne(Organization, {foreignKey: 'owner_id'}); // 1:M Project.hasMany(Task, {foreignkey: 'tasks_pk'}); Task.belongsTo(Project, {foreignKey: 'tasks_pk'}); // N:M User.hasMany(Role, {through: 'user_has_roles', foreignKey: 'user_role_user_id'}); Role.hasMany(User, {through: 'user_has_roles', foreignKey: 'roles_identifier'}); "},"docs/raw-queries.html":{"url":"docs/raw-queries.html","title":"Raw queries","keywords":"","body":"As there are often use cases in which it is just easier to execute raw / already prepared SQL queries, you can utilize the function sequelize.query. By default the function will return two arguments - a results array, and an object containing metadata (affected rows etc.). Note that since this is a raw query, the metadata (property names etc.) is dialect specific. Some dialects return the metadata \"within\" the results object (as properties on an array). However, two arguments will always be returned, but for MSSQL and MySQL it will be two references to the same object. sequelize.query(\"UPDATE users SET y = 42 WHERE x = 12\").spread(function(results, metadata) { // Results will be an empty array and metadata will contain the number of affected rows. }) In cases where you don't need to access the metadata you can pass in a query type to tell sequelize how to format the results. For example, for a simple select query you could do: sequelize.query(\"SELECT * FROM `users`\", { type: sequelize.QueryTypes.SELECT}) .then(function(users) { // We don't need spread here, since only the results will be returned for select queries }) Several other query types are available. Peek into the source for details A second option is the model. If you pass a model the returned data will be instances of that model. // Callee is the model definition. This allows you to easily map a query to a predefined model sequelize.query('SELECT * FROM projects', { model: Projects }).then(function(projects){ // Each record will now be a instance of Project }) Replacements Replacements in a query can be done in two different ways, either using named parameters (starting with :), or unnamed, represented by a ?. Replacements are passed in the options object. If an array is passed, ? will be replaced in the order that they appear in the array If an object is passed, :key will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown. sequelize.query('SELECT * FROM projects WHERE status = ?', { replacements: ['active'], type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) sequelize.query('SELECT * FROM projects WHERE status = :status ', { replacements: { status: 'active' }, type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) Bind Parameter Bind parameters are like replacements. Except replacements are escaped and inserted into the query by sequelize before the query is sent to the database, while bind parameters are sent to the database outside the SQL query text. A query can have either bind parameters or replacements. Only SQLite and PostgreSQL support bind parameters. Other dialects will insert them into the SQL query in the same way it is done for replacements. Bind parameters are referred to by either $1, $2, ... (numeric) or $key (alpha-numeric). This is independent of the dialect. If an array is passed, $1 is bound to the 1st element in the array (bind[0]) If an object is passed, $key is bound to object['key']. Each key must begin with a non-numeric char. $1 is not a valid key, even if object['1'] exists. In either case $$ can be used to escape a literal $ sign. The array or object must contain all bound values or Sequelize will throw an exception. This applies even to cases in which the database may ignore the bound parameter. The database may add further restrictions to this. Bind parameters cannot be SQL keywords, nor table or column names. They are also ignored in quoted text or data. In PostgreSQL it may also be needed to typecast them, if the type cannot be inferred from the context $1::varchar. sequelize.query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $1', { bind: ['active'], type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) sequelize.query('SELECT *, \"text with literal $$1 and literal $$status\" as t FROM projects WHERE status = $status', { bind: { status: 'active' }, type: sequelize.QueryTypes.SELECT } ).then(function(projects) { console.log(projects) }) "},"docs/migrations.html":{"url":"docs/migrations.html","title":"Migrations","keywords":"","body":"Sequelize 2.0.0 introduces a new CLI which is based on gulp and combines sequelize-cli and gulp-sequelize. The CLI ships support for migrations and project bootstrapping. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe the way how to get to the new state and how to revert the changes in order to get back to the old state. The CLI In order to use the CLI you need to install the respective package: $ npm install --save sequelize-cli As with any npm package, you can use the global flag (-g) to install the CLI globally. If you have installed the CLI without the global flag, use node_modules/.bin/sequelize [command] instead of sequelize [command]. The CLI currently supports the following commands: $ sequelize db:migrate # Run pending migrations. $ sequelize db:migrate:undo # Revert the last migration run. $ sequelize help # Display this help text. $ sequelize init # Initializes the project. $ sequelize migration:create # Generates a new migration file. $ sequelize version # Prints the version number. Further and more detailed information about the available commands can be obtained via the help command: $ sequelize help:init $ sequelize help:db:migrate $ sequelize help:db:migrate:undo # etc The latter one for example will print out the following output: Sequelize [CLI: v0.0.2, ORM: v1.7.5] COMMANDS sequelize db:migrate:undo -- Revert the last migration run. DESCRIPTION Revert the last migration run. OPTIONS --env The environment to run the command in. Default: development --options-path The path to a JSON file with additional options. Default: none --coffee Enables coffee script support. Default: false --config The path to the config file. Default: config/config.json Skeleton The following skeleton shows a typical migration file. All migrations are expected to be located in a folder called migrations at the very top of the project. The sequelize binary can generate a migration skeleton. See the above section for more details. module.exports = { up: function(queryInterface, Sequelize) { // logic for transforming into the new state }, down: function(queryInterface, Sequelize) { // logic for reverting the changes } } The passed queryInterface object can be used to modify the database. The Sequelize object stores the available data types such as STRING or INTEGER. Function up or down should return a Promise. Here is some code: module.exports = { up: function(queryInterface, Sequelize) { return queryInterface.dropAllTables(); } } The available methods of the queryInterface object are the following. Functions Using the queryInterface object describe before, you will have access to most of already introduced functions. Furthermore there are some other methods, which are designed to actually change the database schema. createTable(tableName, attributes, options) This method allows creation of new tables. It is allowed to pass simple or complex attribute definitions. You can define the encoding of the table and the table's engine via options queryInterface.createTable( 'nameOfTheNewTable', { id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true }, createdAt: { type: Sequelize.DATE }, updatedAt: { type: Sequelize.DATE }, attr1: Sequelize.STRING, attr2: Sequelize.INTEGER, attr3: { type: Sequelize.BOOLEAN, defaultValue: false, allowNull: false }, //foreign key usage attr4: { type: Sequelize.INTEGER, references: { model: 'another_table_name', key: 'id' }, onUpdate: 'cascade', onDelete: 'cascade' } }, { engine: 'MYISAM', // default: 'InnoDB' charset: 'latin1' // default: null } ) dropTable(tableName, options) This method allows deletion of an existing table. queryInterface.dropTable('nameOfTheExistingTable') dropAllTables(options) This method allows deletion of all existing tables in the database. queryInterface.dropAllTables() renameTable(before, after, options) This method allows renaming of an existing table. queryInterface.renameTable('Person', 'User') showAllTables(options) This method returns the name of all existing tables in the database. queryInterface.showAllTables().then(function(tableNames) {}) describeTable(tableName, options) This method returns an array of hashes containing information about all attributes in the table. queryInterface.describeTable('Person').then(function(attributes) { /* attributes will be something like: { name: { type: 'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg! allowNull: true, defaultValue: null }, isBetaMember: { type: 'TINYINT(1)', // this will be 'BOOLEAN' for pg! allowNull: false, defaultValue: false } } */ }) addColumn(tableName, attributeName, dataTypeOrOptions, options) This method allows adding columns to an existing table. The data type can be simple or complex. queryInterface.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', Sequelize.STRING ) // or queryInterface.addColumn( 'nameOfAnExistingTable', 'nameOfTheNewAttribute', { type: Sequelize.STRING, allowNull: false } ) removeColumn(tableName, attributeName, options) This method allows deletion of a specific column of an existing table. queryInterface.removeColumn('Person', 'signature') changeColumn(tableName, attributeName, dataTypeOrOptions, options) This method changes the meta data of an attribute. It is possible to change the default value, allowance of null or the data type. Please make sure, that you are completely describing the new data type. queryInterface.changeColumn( 'nameOfAnExistingTable', 'nameOfAnExistingAttribute', { type: Sequelize.FLOAT, allowNull: false, defaultValue: 0.0 } ) renameColumn(tableName, attrNameBefore, attrNameAfter, options) This methods allows renaming attributes. queryInterface.renameColumn('Person', 'signature', 'sig') addIndex(tableName, attributes, options) This methods creates indexes for specific attributes of a table. The index name will be automatically generated if it is not passed via in the options (see below). // This example will create the index person_firstname_lastname queryInterface.addIndex('Person', ['firstname', 'lastname']) // This example will create a unique index with the name SuperDuperIndex using the optional 'options' field. // Possible options: // - indicesType: UNIQUE|FULLTEXT|SPATIAL // - indexName: The name of the index. Default is __ // - parser: For FULLTEXT columns set your parser // - indexType: Set a type for the index, e.g. BTREE. See the documentation of the used dialect // - logging: A function that receives the sql query, e.g. console.log queryInterface.addIndex( 'Person', ['firstname', 'lastname'], { indexName: 'SuperDuperIndex', indicesType: 'UNIQUE' } ) removeIndex(tableName, indexNameOrAttributes, options) This method deletes an existing index of a table. queryInterface.removeIndex('Person', 'SuperDuperIndex') // or queryInterface.removeIndex('Person', ['firstname', 'lastname']) Programmatic use Sequelize has a sister library for programmatically handling execution and logging of migration tasks. "},"api/sequelize.html":{"url":"api/sequelize.html","title":"Sequelize","keywords":"","body":" Class Sequelize View code This is the main class, the entry point to sequelize. To use it, you just need to import sequelize: var Sequelize = require('sequelize'); In addition to sequelize, the connection library for the dialect you want to use should also be installed in your project. You don't need to import it however, as sequelize will take care of that. new Sequelize(database, [username=null], [password=null], [options={}]) View code Instantiate sequelize with name of database, username and password Example usage // without password and options var sequelize = new Sequelize('database', 'username') // without options var sequelize = new Sequelize('database', 'username', 'password') // without password / with blank password var sequelize = new Sequelize('database', 'username', null, {}) // with password and options var sequelize = new Sequelize('my_database', 'john', 'doe', {}) // with uri (see below) var sequelize = new Sequelize('mysql://localhost:3306/database', {}) Params: Name Type Description database String The name of the database [username=null] String The username which is used to authenticate against the database. [password=null] String The password which is used to authenticate against the database. [options={}] Object An object with options. [options.dialect='mysql'] String The dialect of the database you are connecting to. One of mysql, postgres, sqlite, mariadb and mssql. [options.dialectModulePath=null] String If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'pg.js' here [options.dialectOptions] Object An object of additional options, which are passed directly to the connection library [options.storage] String Only used by sqlite. Defaults to ':memory:' [options.host='localhost'] String The host of the relational database. [options.port=] Integer The port of the relational database. [options.protocol='tcp'] String The protocol of the relational database. [options.define={}] Object Default options for model definitions. See sequelize.define for options [options.query={}] Object Default options for sequelize.query [options.set={}] Object Default options for sequelize.set [options.sync={}] Object Default options for sequelize.sync [options.timezone='+00:00'] String The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes. [options.logging=console.log] Function A function that gets executed every time Sequelize would log something. [options.omitNull=false] Boolean A flag that defines if null values should be passed to SQL queries or not. [options.native=false] Boolean A flag that defines if native library shall be used or not. Currently only has an effect for postgres [options.replication=false] Boolean Use read / write replication. To enable replication, pass an object, with two properties, read and write. Write should be an object (a single server for handling writes), and read an array of object (several servers to handle reads). Each read/write server can have the following properties: host, port, username, password, database [options.pool={}] Object Should sequelize use a connection pool. Default is true [options.pool.maxConnections] Integer [options.pool.minConnections] Integer [options.pool.maxIdleTime] Integer The maximum time, in milliseconds, that a connection can be idle before being released [options.pool.validateConnection] Function A function that validates a connection. Called with client. The default function checks that client is an object, and that its state is not disconnected [options.quoteIdentifiers=true] Boolean Set to false to make table names and attributes case-insensitive on Postgres and skip double quoting of them. [options.transactionType='DEFERRED'] String Set the default transaction type. See Sequelize.Transaction.TYPES for possible options. Sqlite only. [options.isolationLevel='REPEATABLE_READ'] String Set the default transaction isolation level. See Sequelize.Transaction.ISOLATION_LEVELS for possible options. [options.retry] Object Set of flags that control when a query is automatically retried. [options.retry.match] Array Only retry a query if the error matches one of these strings. [options.retry.max] Integer How many times a failing query is automatically retried. Set to 0 to disable retrying on SQL_BUSY error. [options.typeValidation=false] Boolean Run built in type validators on insert and update, e.g. validate that arguments passed to integer fields are integer-like. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. new Sequelize(uri, [options={}]) View code Instantiate sequelize with an URI Params: Name Type Description uri String A full database URI [options={}] object See above for possible options models View code Models are stored here under the name given to sequelize.define version View code Sequelize version number. Sequelize View code A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc. See: Sequelize Utils View code A reference to sequelize utilities. Most users will not need to use these utils directly. However, you might want to use Sequelize.Utils._, which is a reference to the lodash library, if you don't already have it imported in your project. Promise View code A handy reference to the bluebird Promise class QueryTypes View code Available query types for use with sequelize.query Validator View code Exposes the validator.js object, so you can extend it with custom validation functions. The validator is exposed both on the instance, and on the constructor. See: Transaction View code A reference to the sequelize transaction class. Use this to access isolationLevels and types when creating a transaction See: Transaction Sequelize#transaction Deferrable View code A reference to the deferrable collection. Use this to access the different deferrable options. See: Deferrable Sequelize#transaction Instance View code A reference to the sequelize instance class. See: Instance Association View code A reference to the sequelize association class. See: Association Error View code A general error class See: Errors#BaseError ValidationError View code Emitted when a validation fails See: Errors#ValidationError ValidationErrorItem View code Describes a validation error on an instance path See: Errors#ValidationErrorItem DatabaseError View code A base class for all database related errors. See: Errors#DatabaseError TimeoutError View code Thrown when a database query times out because of a deadlock See: Errors#TimeoutError UniqueConstraintError View code Thrown when a unique constraint is violated in the database See: Errors#UniqueConstraintError ExclusionConstraintError View code Thrown when an exclusion constraint is violated in the database See: Errors#ExclusionConstraintError ForeignKeyConstraintError View code Thrown when a foreign key constraint is violated in the database See: Errors#ForeignKeyConstraintError ConnectionError View code A base class for all connection related errors. See: Errors#ConnectionError ConnectionRefusedError View code Thrown when a connection to a database is refused See: Errors#ConnectionRefusedError AccessDeniedError View code Thrown when a connection to a database is refused due to insufficient access See: Errors#AccessDeniedError HostNotFoundError View code Thrown when a connection to a database has a hostname that was not found See: Errors#HostNotFoundError HostNotReachableError View code Thrown when a connection to a database has a hostname that was not reachable See: Errors#HostNotReachableError InvalidConnectionError View code Thrown when a connection to a database has invalid values for any of the connection parameters See: Errors#InvalidConnectionError ConnectionTimedOutError View code Thrown when a connection to a database times out See: Errors#ConnectionTimedOutError InstanceError View code Thrown when a some problem occurred with Instance methods (see message for details) See: Errors#InstanceError getDialect() -> String View code Returns the specified dialect. Returns: The specified dialect. getQueryInterface() -> QueryInterface View code Returns an instance of QueryInterface. See: QueryInterface Returns: An instance (singleton) of QueryInterface. define(modelName, attributes, [options]) -> Model View code Define a new model, representing a table in the DB. The table columns are define by the hash that is given as the second argument. Each attribute of the hash represents a column. A short table definition might look like this: sequelize.define('modelName', { columnA: { type: Sequelize.BOOLEAN, validate: { is: [\"[a-z]\",'i'], // will only allow letters max: 23, // only allow values As shown above, column definitions can be either strings, a reference to one of the datatypes that are predefined on the Sequelize constructor, or an object that allows you to specify both the type of the column, and other attributes such as default values, foreign key constraints and custom setters and getters. For a list of possible data types, see http://docs.sequelizejs.com/en/latest/docs/models-definition/#data-types For more about getters and setters, see http://docs.sequelizejs.com/en/latest/docs/models-definition/#getters-setters For more about instance and class methods, see http://docs.sequelizejs.com/en/latest/docs/models-definition/#expansion-of-models For more about validation, see http://docs.sequelizejs.com/en/latest/docs/models-definition/#validations See: DataTypes Hooks Params: Name Type Description modelName String The name of the model. The model will be stored in sequelize.models under this name attributes Object An object, where each attribute is a column of the table. Each column can be either a DataType, a string or a type-description object, with the properties described below: attributes.column String | DataType | Object The description of a database column attributes.column.type String | DataType A string or a data type [attributes.column.allowNull=true] Boolean If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved. [attributes.column.defaultValue=null] Any A literal default value, a JavaScript function, or an SQL function (see sequelize.fn) [attributes.column.unique=false] String | Boolean If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index [attributes.column.primaryKey=false] Boolean [attributes.column.field=null] String If set, sequelize will map the attribute name to a different name in the database [attributes.column.autoIncrement=false] Boolean [attributes.column.comment=null] String [attributes.column.references=null] String | Model An object with reference configurations [attributes.column.references.model] String | Model If this column references another table, provide it here as a Model, or a string [attributes.column.references.key='id'] String The column of the foreign table that this column references [attributes.column.onUpdate] String What should happen when the referenced key is updated. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.onDelete] String What should happen when the referenced key is deleted. One of CASCADE, RESTRICT, SET DEFAULT, SET NULL or NO ACTION [attributes.column.get] Function Provide a custom getter for this column. Use this.getDataValue(String) to manipulate the underlying values. [attributes.column.set] Function Provide a custom setter for this column. Use this.setDataValue(String, Value) to manipulate the underlying values. [attributes.validate] Object An object of validations to execute for this column every time the model is saved. Can be either the name of a validation provided by validator.js, a validation function provided by extending validator.js (see the DAOValidator property for more details), or a custom validation function. Custom validation functions are called with the value of the field, and can possibly take a second callback argument, to signal that they are asynchronous. If the validator is sync, it should throw in the case of a failed validation, it it is async, the callback should be called with the error text. [options] Object These options are merged with the default define options provided to the Sequelize constructor [options.defaultScope={}] Object Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll [options.scopes] Object More scopes, defined in the same way as defaultScope above. See Model.scope for more information about how scopes are defined, and what you can do with them [options.omitNull] Boolean Don't persist null values. This means that all columns with null values will not be saved [options.timestamps=true] Boolean Adds createdAt and updatedAt timestamps to the model. [options.paranoid=false] Boolean Calling destroy will not delete the model, but instead set a deletedAt timestamp if this is true. Needs timestamps=true to work [options.underscored=false] Boolean Converts all camelCased columns to underscored if true [options.underscoredAll=false] Boolean Converts camelCased model names to underscored table names if true [options.freezeTableName=false] Boolean If freezeTableName is true, sequelize will not try to alter the DAO name to get the table name. Otherwise, the model name will be pluralized [options.name] Object An object with two attributes, singular and plural, which are used when this model is associated to others. [options.name.singular=inflection.singularize(modelName)] String [options.name.plural=inflection.pluralize(modelName)] String [options.indexes] Array. [options.indexes[].name] String The name of the index. Defaults to model name + _ + fields concatenated [options.indexes[].type] String Index type. Only used by mysql. One of UNIQUE, FULLTEXT and SPATIAL [options.indexes[].method] String The method to create the index by (USING statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN. [options.indexes[].unique=false] Boolean Should the index by unique? Can also be triggered by setting type to UNIQUE [options.indexes[].concurrently=false] Boolean PostgreSQL will build the index without taking any write locks. Postgres only [options.indexes[].fields] Array. An array of the fields to index. Each field can either be a string containing the name of the field, a sequelize object (e.g sequelize.fn), or an object with the following attributes: attribute (field name), length (create a prefix index of length chars), order (the direction the column should be sorted in), collate (the collation (sort order) for the column) [options.createdAt] String | Boolean Override the name of the createdAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.updatedAt] String | Boolean Override the name of the updatedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.deletedAt] String | Boolean Override the name of the deletedAt column if a string is provided, or disable it if false. Timestamps must be true. Not affected by underscored setting. [options.tableName] String Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim [options.getterMethods] Object Provide getter functions that work like those defined per column. If you provide a getter method with the same name as a column, it will be used to access the value of that column. If you provide a name that does not match a column, this function will act as a virtual getter, that can fetch multiple other values [options.setterMethods] Object Provide setter functions that work like those defined per column. If you provide a setter method with the same name as a column, it will be used to update the value of that column. If you provide a name that does not match a column, this function will act as a virtual setter, that can act on and set other values, but will not be persisted [options.instanceMethods] Object Provide functions that are added to each instance (DAO). If you override methods provided by sequelize, you can access the original method using this.constructor.super_.prototype, e.g. this.constructor.super_.prototype.toJSON.apply(this, arguments) [options.classMethods] Object Provide functions that are added to the model (Model). If you override methods provided by sequelize, you can access the original method using this.constructor.prototype, e.g. this.constructor.prototype.find.apply(this, arguments) [options.schema='public'] String [options.engine] String [options.charset] String [options.comment] String [options.collate] String [options.initialAutoIncrement] String Set the initial AUTO_INCREMENT value for the table in MySQL. [options.hooks] Object An object of hook function that are called before and after certain lifecycle events. The possible hooks are: beforeValidate, afterValidate, beforeBulkCreate, beforeBulkDestroy, beforeBulkUpdate, beforeCreate, beforeDestroy, beforeUpdate, afterCreate, afterDestroy, afterUpdate, afterBulkCreate, afterBulkDestory and afterBulkUpdate. See Hooks for more information about hook functions and their signatures. Each property can either be a function, or an array of functions. [options.validate] Object An object of model wide validations. Validations have access to all model values via this. If the validator function takes an argument, it is assumed to be async, and is called with a callback that accepts an optional error. model(modelName) -> Model View code Fetch a Model which is already defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define isDefined(modelName) -> Boolean View code Checks whether a model with the given name is defined Params: Name Type Description modelName String The name of a model defined with Sequelize.define import(path) -> Model View code Imports a model defined in another file Imported models are cached, so multiple calls to import with the same path will not load the file multiple times See https://github.com/sequelize/express-example for a short example of how to define your models in separate files so that they can be imported by sequelize.import Params: Name Type Description path String The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file query(sql, [options={}]) -> Promise View code Execute a query on the DB, with the possibility to bypass all the sequelize goodness. By default, the function will return two arguments: an array of results, and a metadata object, containing number of affected rows etc. Use .spread to access the results. If you are running a type of query where you don't need the metadata, for example a SELECT query, you can pass in a query type to make sequelize format the results: sequelize.query('SELECT...').spread(function (results, metadata) { // Raw query - use spread }); sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }).then(function (results) { // SELECT query - use then }) See: Model#build Params: Name Type Description sql String [options={}] Object Query options. [options.raw] Boolean If true, sequelize will not try to format the results of the query, or build an instance of a model from the result [options.transaction=null] Transaction The transaction that the query should be executed under [options.type='RAW'] String The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but Sequelize.QueryTypes is provided as convenience shortcuts. [options.nest=false] Boolean If true, transforms objects with . separated property names into nested objects using dottie.js. For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When nest is true, the query type is assumed to be 'SELECT', unless otherwise specified [options.plain=false] Boolean Sets the query type to SELECT and return a single row [options.replacements] Object | Array Either an object of named parameter replacements in the format :param or an array of unnamed replacements to replace ? in your SQL. [options.bind] Object | Array Either an object of named bind parameter in the format $param or an array of unnamed bind parameter to replace $1, $2, ... in your SQL. [options.useMaster=false] Boolean Force the query to use the write pool, regardless of the query type. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.instance] Instance A sequelize instance used to build the return instance [options.model] Model A sequelize model used to build the returned model instances (used to be called callee) [options.retry] Object Set of flags that control when a query is automatically retried. [options.retry.match] Array Only retry a query if the error matches one of these strings. [options.retry.max] Integer How many times a failing query is automatically retried. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.supportsSearchPath] Boolean If false do not prepend the query with the search_path (Postgres only) [options.mapToModel=false] Object Map returned fields to model's fields if options.model or options.instance is present. Mapping will occur before building the model instance. [options.fieldMap] Object Map returned fields to arbitrary names for SELECT query type. set(variables, options) -> Promise View code Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction. Only works for MySQL. Params: Name Type Description variables Object Object with multiple variables. options Object Query options. options.transaction Transaction The transaction that the query should be executed under escape(value) -> String View code Escape value. Params: Name Type Description value String createSchema(schema, options={}) -> Promise View code Create a new database schema. Note,that this is a schema in the postgres sense of the word, not a database table. In mysql and sqlite, this command will do nothing. See: Model#schema Params: Name Type Description schema String Name of the schema options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging showAllSchemas(options={}) -> Promise View code Show all defined schemas Note,that this is a schema in the postgres sense of the word, not a database table. In mysql and sqlite, this will show all tables. Params: Name Type Description options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging dropSchema(schema, options={}) -> Promise View code Drop a single schema Note,that this is a schema in the postgres sense of the word, not a database table. In mysql and sqlite, this drop a table matching the schema name Params: Name Type Description schema String Name of the schema options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging dropAllSchemas(options={}) -> Promise View code Drop all schemas Note,that this is a schema in the postgres sense of the word, not a database table. In mysql and sqlite, this is the equivalent of drop all tables. Params: Name Type Description options={} Object options.logging Boolean | function A function that logs sql queries, or false for no logging sync([options={}]) -> Promise View code Sync all defined models to the DB. Params: Name Type Description [options={}] Object [options.force=false] Boolean If force is true, each DAO will do DROP TABLE IF EXISTS ..., before it tries to create its own table [options.match] RegEx Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code [options.logging=console.log] Boolean | function A function that logs sql queries, or false for no logging [options.schema='public'] String The schema that the tables should be created in. This can be overriden for each table in sequelize.define [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.hooks=true] Boolean If hooks is true then beforeSync, afterSync, beforBulkSync, afterBulkSync hooks will be called truncate([options]) -> Promise View code Truncate all tables defined through the sequelize models. This is done by calling Model.truncate() on each model. See: Model#truncate Params: Name Type Description [options] object The options passed to Model.destroy in addition to truncate [options.transaction] Boolean | function [options.logging] Boolean | function A function that logs sql queries, or false for no logging drop(options) -> Promise View code Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model See: Model#drop Params: Name Type Description options object The options passed to each call to Model.drop options.logging Boolean | function A function that logs sql queries, or false for no logging authenticate() -> Promise View code Test the connection by trying to authenticate Aliases: validate fn(fn, args) -> Sequelize.fn View code Creates a object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions. If you want to refer to columns in your function, you should use sequelize.col, so that the columns are properly interpreted as columns and not a strings. Convert a user's username to upper case instance.updateAttributes({ username: self.sequelize.fn('upper', self.sequelize.col('username')) }) Alternatively, a condition object can be used as an argument e.g. to get the count of rows for which the predicate evaluates to true. Works on mysql and sqlite. sequelize.fn('sum', { age: { $gt: 25 }, name: 'Joe' }) An explicit cast is required on postgres. sequelize.fn('sum', sequelize.cast({ age: { $gt: 25 }, name: 'Joe' }, 'int')) See: Model#find Model#findAll Model#define Sequelize#col Params: Name Type Description fn String The function you want to call args any All further arguments will be passed as arguments to the function. An argument may be a condition object. col(col) -> Sequelize.col View code Creates a object representing a column in the DB. This is often useful in conjunction with sequelize.fn, since raw string arguments to fn will be escaped. See: Sequelize#fn Params: Name Type Description col String The name of the column cast(val, type) -> Sequelize.cast View code Creates a object representing a call to the cast function. Params: Name Type Description val any The value to cast type String The type to cast it to literal(val) -> Sequelize.literal View code Creates a object representing a literal, i.e. something that will not be escaped. Params: Name Type Description val any Aliases: asIs and(args) -> Sequelize.and View code An AND query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by AND or(args) -> Sequelize.or View code An OR query See: Model#find Params: Name Type Description args String | Object Each argument will be joined by OR json(conditions, [value]) -> Sequelize.json View code Creates an object representing nested where conditions for postgres's json data-type. See: Model#find Params: Name Type Description conditions String | Object A hash containing strings/numbers or other nested hash, a string using dot notation or a string using postgres json syntax. [value] String | Number | Boolean An optional value to compare against. Produces a string of the form \" = ''\". where(attr, [comparator='='], logic) -> Sequelize.where View code A way of specifying attr = condition. The attr can either be an object taken from Model.rawAttributes (for example Model.rawAttributes.id or Model.rawAttributes.name). The attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (sequelize.fn, sequelize.col etc.) For string attributes, use the regular { where: { attr: something }} syntax. If you don't want your string to be escaped, use sequelize.literal. See: Model#find Params: Name Type Description attr Object The attribute, which can be either an attribute object from Model.rawAttributes or a sequelize object, for example an instance of sequelize.fn. For simple string attributes, use the POJO syntax [comparator='='] string logic String | Object The condition. Can be both a simply type, or a further condition ($or, $and, .literal etc.) Aliases: condition transaction([options={}]) -> Promise View code Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction sequelize.transaction().then(function (t) { return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }) .then(t.commit.bind(t)) .catch(t.rollback.bind(t)); }) A syntax for automatically committing or rolling back based on the promise chain resolution is also supported: sequelize.transaction(function (t) { // Note that we use a callback rather than a promise.then() return User.find(..., { transaction: t}).then(function (user) { return user.updateAttributes(..., { transaction: t}); }); }).then(function () { // Committed }).catch(function (err) { // Rolled back console.error(err); }); If you have CLS enabled, the transaction will automatically be passed to any query that runs within the callback. To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor: var cls = require('continuation-local-storage'), ns = cls.createNamespace('....'); var Sequelize = require('sequelize'); Sequelize.cls = ns; Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace See: Transaction Params: Name Type Description [options={}] Object [options.autocommit=true] Boolean [options.type='DEFERRED'] String See Sequelize.Transaction.TYPES for possible options. Sqlite only. [options.isolationLevel='REPEATABLE_READ'] String See Sequelize.Transaction.ISOLATION_LEVELS for possible options [options.logging=false] Function A function that gets executed while running the query to log the sql. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/model.html":{"url":"api/model.html","title":"Model","keywords":"","body":" Class Model View code A Model represents a table in the database. Sometimes you might also see it referred to as model, or simply as factory. This class should not be instantiated directly, it is created using sequelize.define, and already created models can be loaded using sequelize.import Mixes: Hooks Associations removeAttribute([attribute]) View code Remove attribute from model definition Params: Name Type Description [attribute] String sync() -> Promise. View code Sync this Model to the DB, that is create the table. Upon success, the callback will be called with the model instance (this) See: Sequelize#sync drop([options]) -> Promise View code Drop the table represented by this Model Params: Name Type Description [options] Object [options.cascade=false] Boolean Also drop all objects depending on this table, such as views. Only works in postgres [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. schema(schema, [options]) -> this View code Apply a schema to this model. For postgres, this will actually place the schema in front of the table name - \"schema\".\"tableName\", while the schema will be prepended to the table name for mysql and sqlite - 'schema.tablename'. Params: Name Type Description schema String The name of the schema [options] Object [options.schemaDelimiter='.'] String The character(s) that separates the schema name from the table name [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. getTableName([options]) -> String|Object View code Get the tablename of the model, taking schema into account. The method will return The name as a string if the model has no schema, or an object with tableName, schema and delimiter properties. Params: Name Type Description [options] Object The hash of options from any query. You can use one model to access tables with matching schemas by overriding getTableName and using custom key/values to alter the name of the table. (eg. subscribers_1, subscribers_2) [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. unscoped() -> Model View code addScope(name, scope, [options]) View code Add a new scope to the model. This is especially useful for adding scopes with includes, when the model you want to include is not available at the time this model is defined. By default this will throw an error if a scope with that name already exists. Pass override: true in the options object to silence this error. Params: Name Type Description name String The name of the scope. Use defaultScope to override the default scope scope Object | Function [options] Object [options.override=false] Boolean scope(options*) -> Model View code Apply a scope created in define to the model. First let's look at how to create scopes: var Model = sequelize.define('model', attributes, { defaultScope: { where: { username: 'dan' }, limit: 12 }, scopes: { isALie: { where: { stuff: 'cake' } }, complexFunction: function(email, accessLevel) { return { where: { email: { $like: email }, accesss_level { $gte: accessLevel } } } } } }) Now, since you defined a default scope, every time you do Model.find, the default scope is appended to your query. Here's a couple of examples: Model.findAll() // WHERE username = 'dan' Model.findAll({ where: { age: { gt: 12 } } }) // WHERE age > 12 AND username = 'dan' To invoke scope functions you can do: Model.scope({ method: ['complexFunction' 'dan@sequelize.com', 42]}).findAll() // WHERE email like 'dan@sequelize.com%' AND access_level >= 42 Params: Name Type Description options* Array | Object | String The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a method property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default. Returns: A reference to the model, with the scope(s) applied. Calling scope again on the returned model will clear the previous scope. findAll([options]) -> Promise.> View code Search for multiple instances. Simple search using AND and = Model.findAll({ where: { attr1: 42, attr2: 'cake' } }) WHERE attr1 = 42 AND attr2 = 'cake' Using greater than, less than etc. Model.findAll({ where: { attr1: { gt: 50 }, attr2: { lte: 45 }, attr3: { in: [1,2,3] }, attr4: { ne: 5 } } }) WHERE attr1 > 50 AND attr2 Possible options are: $ne, $in, $not, $notIn, $gte, $gt, $lte, $lt, $like, $ilike/$iLike, $notLike, $notILike, '..'/$between, '!..'/$notBetween, '&&'/$overlap, '@>'/$contains, ' Queries using OR Model.findAll({ where: { name: 'a project', $or: [ {id: [1, 2, 3]}, { $and: [ {id: {gt: 10}}, {id: {lt: 100}} ] } ] } }); WHERE `Model`.`name` = 'a project' AND (`Model`.`id` IN (1, 2, 3) OR (`Model`.`id` > 10 AND `Model`.`id` The success listener is called with an array of instances if the query succeeds. See: Sequelize#query Params: Name Type Description [options] Object A hash of options to describe the scope of the search [options.where] Object A hash of attributes to describe your search. See above for examples. [options.attributes] Array. | Object A list of the attributes that you want to select, or an object with include and exclude keys. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as Sequelize.literal, Sequelize.fn and so on), and the second is the name you want the attribute to have in the returned instance [options.attributes.include] Array. Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. { attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] } [options.attributes.exclude] Array. Select all the attributes of the model, except some few. Useful for security purposes e.g. { attributes: { exclude: ['password'] } } [options.paranoid=true] Boolean If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if options.paranoid is true for the model. [options.include] Array. A list of associations to eagerly load using a left join. Supported is either { include: [ Model1, Model2, ...]} or { include: [{ model: Model1, as: 'Alias' }]}. If your association are set up with an as (eg. X.hasMany(Y, { as: 'Z }, you need to specify Z in the as attribute when eager loading Y). [options.include[].model] Model The model you want to eagerly load [options.include[].as] String The alias of the relation, in case the model you want to eagerly load is aliased. For hasOne / belongsTo, this should be the singular name, and for hasMany, it should be the plural [options.include[].association] Association The association you want to eagerly load. (This can be used instead of providing a model/as pair) [options.include[].where] Object Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set required: false [options.include[].or=false] Boolean Whether to bind the ON and WHERE clause together by OR instead of AND. [options.include[].on] Object Supply your own ON condition for the join. [options.include[].attributes] Array. A list of attributes to select from the child model [options.include[].required] Boolean If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if include.where is set, false otherwise. [options.include[].separate] Boolean If true, runs a separate query to fetch the associated instances, only supported for hasMany associations [options.include[].limit] Number Limit the joined rows, only supported with include.separate=true [options.include[].through.where] Object Filter on the join model for belongsToMany relations [options.include[].through.attributes] Array A list of attributes to select from the join model for belongsToMany relations [options.include[].include] Array. Load further nested related models [options.order] String | Array | Sequelize.fn Specifies an ordering. If a string is provided, it will be escaped. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: order: [['name', 'DESC']]. In this way the column will be escaped, but the direction will not. [options.limit] Number [options.offset] Number [options.transaction] Transaction Transaction to run query under [options.lock] String | Object Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See transaction.LOCK for an example [options.raw] Boolean Return raw result. See sequelize.query for more information. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.having] Object [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Aliases: all findById(id, [options]) -> Promise. View code Search for a single instance by its primary key. See: Model#findAll Params: Name Type Description id Number | String | Buffer The value of the desired instance's primary key. [options] Object [options.transaction] Transaction Transaction to run query under [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) Aliases: findByPrimary findOne([options]) -> Promise. View code Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance. See: Model#findAll Params: Name Type Description [options] Object A hash of options to describe the scope of the search [options.transaction] Transaction Transaction to run query under [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) Aliases: find aggregate(field, aggregateFunction, [options]) -> Promise. View code Run an aggregation method on the specified field Params: Name Type Description field String The field to aggregate over. Can be a field name or * aggregateFunction String The function to use for aggregation, e.g. sum, max etc. [options] Object Query options. See sequelize.query for full options [options.where] Object A hash of search attributes. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.dataType] DataType | String The type of the result. If field is a field in this Model, the default will be the type of that field, otherwise defaults to float. [options.distinct] boolean Applies DISTINCT to the field being aggregated over [options.transaction] Transaction Transaction to run query under [options.plain] Boolean When true, the first returned value of aggregateFunction is cast to dataType and returned. If additional attributes are specified, along with group clauses, set plain to false to return all values of all returned rows. Defaults to true [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: Returns the aggregate result cast to options.dataType, unless options.plain is false, in which case the complete data result is returned. count([options]) -> Promise. View code Count the number of records matching the provided where clause. If you provide an include option, the number of matching associations will be counted instead. Params: Name Type Description [options] Object [options.where] Object A hash of search attributes. [options.include] Object Include options. See find for details [options.distinct] boolean Apply COUNT(DISTINCT(col)) on primary key, Model.aggregate should be used for other columns [options.attributes] Object Used in conjunction with group [options.group] Object For creating complex counts. Will return multiple rows as needed. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. findAndCount([findOptions]) -> Promise. View code Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging Model.findAndCountAll({ where: ..., limit: 12, offset: 12 }).then(function (result) { ... }) In the above example, result.rows will contain rows 13 through 24, while result.count will return the total number of rows that matched your query. When you add includes, only those which are required (either because they have a where clause, or because required is explicitly set to true on the include) will be added to the count part. Suppose you want to find all users who have a profile attached: User.findAndCountAll({ include: [ { model: Profile, required: true} ], limit 3 }); Because the include for Profile has required set it will result in an inner join, and only the users who have a profile will be counted. If we remove required from the include, both users with and without profiles will be counted See: Model#findAll Params: Name Type Description [findOptions] Object See findAll Aliases: findAndCountAll max(field, [options]) -> Promise. View code Find the maximum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate min(field, [options]) -> Promise. View code Find the minimum value of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate sum(field, [options]) -> Promise. View code Find the sum of field See: Model#aggregate Params: Name Type Description field String [options] Object See aggregate build(values, [options]) -> Instance View code Builds a new model instance. Values is an object of key value pairs, must be defined but can be empty. Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.include] Array an array of include options - Used to build prefetched/included model instances. See set create(values, [options]) -> Promise. View code Builds a new model instance and calls save on it. See: Instance#build Instance#save Params: Name Type Description values Object [options] Object [options.raw=false] Boolean If set to true, values will ignore field and virtual setters. [options.isNewRecord=true] Boolean [options.fields] Array If set, only columns matching those in fields will be saved [options.include] Array an array of include options - Used to build prefetched/included model instances [options.onDuplicate] String [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. findOrInitialize -> Promise. View code Find a row that matches the query, or build (but don't save) the row if none is found. The successful result of the promise will be (instance, initialized) - Make sure to use .spread() Params: Name Type Description options Object options.where Object A hash of search attributes. [options.defaults] Object Default values to use if building a new instance [options.transaction] Object Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Aliases: findOrBuild findOrCreate(options) -> Promise. View code Find a row that matches the query, or build and save the row if none is found The successful result of the promise will be (instance, created) - Make sure to use .spread() If no transaction is passed in the options object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize.TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally. See: Model#findAll Params: Name Type Description options Object options.where Object where A hash of search attributes. [options.defaults] Object Default values to use if creating a new instance [options.transaction] Transaction Transaction to run query under findCreateFind(options) -> Promise. View code A more performant findOrCreate that will not work under a transaction (at least not in postgres) Will execute a find call, if empty then attempt to create, if unique constraint then attempt to find again See: Model#findAll Params: Name Type Description options Object options.where Object where A hash of search attributes. [options.defaults] Object Default values to use if creating a new instance upsert(values, [options]) -> Promise. View code Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated. Implementation details: MySQL - Implemented as a single query INSERT values ON DUPLICATE KEY UPDATE values PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE SQLite - Implemented as two queries INSERT; UPDATE. This means that the update is executed regardless of whether the row already existed or not Note that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not. Params: Name Type Description values Object [options] Object [options.validate=true] Boolean Run validations before the row is inserted [options.fields=Object.keys(this.attributes)] Array The fields to insert / update. Defaults to all fields [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: Returns a boolean indicating whether the row was created or updated. Aliases: insertOrUpdate bulkCreate(records, [options]) -> Promise.> View code Create and insert multiple instances in bulk. The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records. To obtain Instances for the newly created values, you will need to query for them again. Params: Name Type Description records Array List of objects (key/value pairs) to create instances from [options] Object [options.fields] Array Fields to insert (defaults to all fields) [options.validate=false] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk create hooks? [options.individualHooks=false] Boolean Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true. [options.ignoreDuplicates=false] Boolean Ignore duplicate values for primary keys? (not supported by postgres) [options.updateOnDuplicate] Array Fields to update if row key already exists (on duplicate key update)? (only supported by mysql & mariadb). By default, all fields are updated. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.returning=false] Boolean Append RETURNING * to get back auto generated values (Postgres only) [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. truncate([options]) -> Promise View code Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }). See: Model#destroy Params: Name Type Description [options] object The options passed to Model.destroy in addition to truncate [options.transaction] Boolean | function Transaction to run query under [options.cascade Boolean | function = false] Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE. [options.transaction] Transaction Transaction to run query under [options.logging] Boolean | function A function that logs sql queries, or false for no logging [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. destroy(options) -> Promise. View code Delete multiple instances, or set their deletedAt timestamp to the current time if paranoid is enabled. Params: Name Type Description options Object [options.where] Object Filter the destroy [options.hooks=true] Boolean Run before / after bulk destroy hooks? [options.individualHooks=false] Boolean If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row [options.limit] Number How many rows to delete [options.force=false] Boolean Delete instead of setting deletedAt to current timestamp (only applicable if paranoid is enabled) [options.truncate=false] Boolean If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored [options.cascade=false] Boolean Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE. [options.restartIdentity=false] Boolean Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table. Postgres only. [options.transaction] Transaction Transaction to run query under [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. Returns: The number of destroyed rows restore(options) -> Promise. View code Restore multiple instances if paranoid is enabled. Params: Name Type Description options Object [options.where] Object Filter the restore [options.hooks=true] Boolean Run before / after bulk restore hooks? [options.individualHooks=false] Boolean If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row [options.limit] Number How many rows to undelete [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. [options.transaction] Transaction Transaction to run query under update(values, options) -> Promise.> View code Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number of affected rows, while the second element is the actual affected rows (only supported in postgres with options.returning true.) Params: Name Type Description values Object options Object options.where Object Options to describe the scope of the search. [options.fields] Array Fields to update (defaults to all fields) [options.validate=true] Boolean Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation [options.hooks=true] Boolean Run before / after bulk update hooks? [options.sideEffects=true] Boolean Whether or not to update the side effects of any virtual setters. [options.individualHooks=false] Boolean Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks [options.returning=false] Boolean Return the affected rows (only for postgres) [options.limit] Number How many rows to update (only for mysql and mariadb) [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.benchmark=false] Boolean Print query execution time in milliseconds when logging SQL. [options.transaction] Transaction Transaction to run query under [options.silent=false] Boolean If true, the updatedAt timestamp will not be updated. describe() -> Promise View code Run a describe query on the table. The result will be return to the listener as a hash of attributes and their types. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/instance.html":{"url":"api/instance.html","title":"Instance","keywords":"","body":" Class Instance View code This class represents an single instance, a database row. You might see it referred to as both Instance and instance. You should not instantiate the Instance class directly, instead you access it using the finder and creation methods on the model. Instance instances operate with the concept of a dataValues property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is: instance.field // is the same as instance.get('field') // is the same as instance.getDataValue('field') However, if getters and/or setters are defined for field they will be invoked, instead of returning the value from dataValues. Accessing properties directly or using get is preferred for regular use, getDataValue should only be used for custom getters. See: Sequelize#define isNewRecord -> Boolean View code Returns true if this instance has not yet been persisted to the database Model() -> Model View code Returns the Model the instance was created from. See: Model sequelize() -> Sequelize View code A reference to the sequelize instance See: Sequelize where() -> Object View code Get an object representing the query for this instance, use with options.where getDataValue(key) -> any View code Get the value of the underlying data value Params: Name Type Description key String setDataValue(key, value) View code Update the underlying data value Params: Name Type Description key String value any get([key], [options]) -> Object|any View code If no key is given, returns all values of the instance, also invoking virtual getters. If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key. Params: Name Type Description [key] String [options] Object [options.plain=false] Boolean If set to true, included instances will be returned as plain objects set(key, value, [options]) View code Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call save). In its most basic form set will update a value stored in the underlying dataValues object. However, if a custom setter function is defined for the key, that function will be called instead. To bypass the setter, you can pass raw: true in the options object. If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values. When set is called, the previous value of the field is stored and sets a changed flag(see changed). Set can also be used to build instances for associations, if you have values for those. When using set with associations you need to make sure the property key matches the alias of the association while also making sure that the proper include options have been set (from .build() or .find()) If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed. See: Model#find Params: Name Type Description key String | Object value any [options] Object [options.raw=false] Boolean If set to true, field and virtual setters will be ignored [options.reset=false] Boolean Clear all previously set data values Aliases: setAttributes changed([key]) -> Boolean|Array View code If changed is called with a string it will return a boolean indicating whether the value of that key in dataValues is different from the value in _previousDataValues. If changed is called without an argument, it will return an array of keys that have changed. If changed is called without an argument and no keys have changed, it will return false. Params: Name Type Description [key] String previous([key]) -> any|Array. View code Returns the previous value for key from _previousDataValues. If called without a key, returns the previous values for all values which have changed Params: Name Type Description [key] String save([options]) -> Promise. View code Validate this instance, and if the validation passes, persist it to the database. It will only save changed fields, and do nothing if no fields have changed. On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of Sequelize.ValidationError. This error will have a property for each of the fields for which validation failed, with the error message for that field. Params: Name Type Description [options] Object [options.fields] Array. An optional array of strings, representing database columns. If fields is provided, only those columns will be validated and saved. [options.silent=false] Boolean If true, the updatedAt timestamp will not be updated. [options.validate=true] Boolean If false, validations won't be run. [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) reload([options]) -> Promise. View code Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object. This is different from doing a find(Instance.id), because that would create and return a new instance. With this method, all references to the Instance are updated with the new data and no new objects are created. See: Model#find Params: Name Type Description [options] Object Options that are passed on to Model.find [options.logging=false] Function A function that gets executed while running the query to log the sql. validate([options]) -> Promise. View code Validate the attribute of this instance according to validation rules set in the model definition. Emits null if and only if validation successful; otherwise an Error instance containing { field name : [error msgs] } entries. See: InstanceValidator Params: Name Type Description [options] Object Options that are passed to the validator [options.skip] Array An array of strings. All properties that are in this array will not be validated update(updates, options) -> Promise. View code This is the same as calling set and then calling save but it only saves the exact values passed to it, making it more atomic and safer. See: Instance#set Instance#save Params: Name Type Description updates Object See set options Object See save Aliases: updateAttributes destroy([options={}]) -> Promise. View code Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time. Params: Name Type Description [options={}] Object [options.force=false] Boolean If set to true, paranoid models will actually be deleted [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) restore([options={}]) -> Promise. View code Restore the row corresponding to this instance. Only available for paranoid models. Params: Name Type Description [options={}] Object [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction increment(fields, [options]) -> Promise. View code Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a SET column = column + X query. To get the correct value after an increment into the Instance you should do a reload. instance.increment('number') // increment number by 1 instance.increment(['number', 'count'], { by: 2 }) // increment number and count by 2 instance.increment({ answer: 42, tries: 1}, { by: 2 }) // increment answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array | Object If a string is provided, that column is incremented by the value of by given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given. [options] Object [options.by=1] Integer The number to increment by [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) decrement(fields, [options]) -> Promise View code Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a SET column = column - X query. To get the correct value after an decrement into the Instance you should do a reload. instance.decrement('number') // decrement number by 1 instance.decrement(['number', 'count'], { by: 2 }) // decrement number and count by 2 instance.decrement({ answer: 42, tries: 1}, { by: 2 }) // decrement answer by 42, and tries by 1. // `by` is ignored, since each column has its own value See: Instance#reload Params: Name Type Description fields String | Array | Object If a string is provided, that column is decremented by the value of by given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given [options] Object [options.by=1] Integer The number to decrement by [options.logging=false] Function A function that gets executed while running the query to log the sql. [options.transaction] Transaction [options.searchPath=DEFAULT] String An optional parameter to specify the schema search_path (Postgres only) equals(other) -> Boolean View code Check whether all values of this and other Instance are the same Params: Name Type Description other Instance equalsOneOf(others) -> Boolean View code Check if this is equal to one of others by calling equals Params: Name Type Description others Array toJSON() -> object View code Convert the instance to a JSON representation. Proxies to calling get with no keys. This means get all values gotten from the DB, and apply all custom getters. See: Instance#get This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/associations/":{"url":"api/associations/","title":"Associations","keywords":"","body":" Mixin Associations View code Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target). hasOne - adds a foreign key to the target and singular association mixins to the source. belongsTo - add a foreign key and singular association mixins to the source. hasMany - adds a foreign key to target and plural association mixins to the source. belongsToMany - creates an N:M association with a join table and adds plural association mixins to the source. The junction table is created with sourceId and targetId. Creating an association will add a foreign key constraint to the attributes. All associations use CASCADE on update and SET NULL on delete, except for n:m, which also uses CASCADE on delete. When creating associations, you can provide an alias, via the as option. This is useful if the same model is associated twice, or you want your association to be called something other than the name of the target model. As an example, consider the case where users have many pictures, one of which is their profile picture. All pictures have a userId, but in addition the user model also has a profilePictureId, to be able to easily load the user's profile picture. User.hasMany(Picture) User.belongsTo(Picture, { as: 'ProfilePicture', constraints: false }) user.getPictures() // gets you all pictures user.getProfilePicture() // gets you only the profile picture User.findAll({ where: ..., include: [ { model: Picture }, // load all pictures { model: Picture, as: 'ProfilePicture' }, // load the profile picture. Notice that the spelling must be the exact same as the one in the association ] }) To get full control over the foreign key column added by sequelize, you can use the foreignKey option. It can either be a string, that specifies the name, or and object type definition, equivalent to those passed to sequelize.define. User.hasMany(Picture, { foreignKey: 'uid' }) The foreign key column in Picture will now be called uid instead of the default userId. User.hasMany(Picture, { foreignKey: { name: 'uid', allowNull: false } }) This specifies that the uid column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see constraints: false below). When fetching associated models, you can limit your query to only load some models. These queries are written in the same way as queries to find/findAll. To only get pictures in JPG, you can do: user.getPictures({ where: { format: 'jpg' } }) There are several ways to update and add new associations. Continuing with our example of users and pictures: user.addPicture(p) // Add a single picture user.setPictures([p1, p2]) // Associate user with ONLY these two picture, all other associations will be deleted user.addPictures([p1, p2]) // Associate user with these two pictures, but don't touch any current associations You don't have to pass in a complete object to the association functions, if your associated model has a single primary key: user.addPicture(req.query.pid) // Here pid is just an integer, representing the primary key of the picture In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it. Note how we also specified constraints: false for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of Error: Cyclic dependency found. 'users' is dependent of itself. If you encounter this, you should either disable some constraints, or rethink your associations completely. hasOne(target, [options]) View code Creates an association between this (the source) and the provided target. The foreign key is added on the target. Example: User.hasOne(Profile). This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}), the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the target table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.onDelete='SETNULL | CASCADE'] string SET NULL if foreignKey allows nulls, CASCADE if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. belongsTo(target, [options]) View code Creates an association between this (the source) and the provided target. The foreign key is added on the source. Example: Profile.belongsTo(User). This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}), the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string The alias of this model, in singular form. See also the name option passed to sequelize.define. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target [options.foreignKey] string | object The name of the foreign key in the source table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of target + primary key of target [options.targetKey] string The name of the field to use as the key for the association in the target table. Defaults to the primary key of the target table [options.onDelete='SETNULL | NOACTION'] string SET NULL if foreignKey allows nulls, NO ACTION if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. hasMany(target, [options]) View code Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target. Example: User.hasMany(Profile). This will add userId to the profile table. Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}), the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.as] string | object The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with plural and singular keys. See also the name option passed to sequelize.define. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target [options.foreignKey] string | object The name of the foreign key in the target table or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.scope] object A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M) [options.onDelete='SETNULL | CASCADE'] string SET NULL if foreignKey allows nulls, CASCADE if otherwise [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. belongsToMany(target, [options]) View code Create an N:M association with a join table. User.belongsToMany(Project, { through: 'UserProjects' }) Project.belongsToMany(User, { through: 'UserProjects' }) Defining through is required. Sequelize would previously attempt to auto generate names but that would not always lead to the most logical setups. If you define a through model with custom attributes, these attributes can be set when adding / setting new associations in two ways. Consider users and projects from before with a join table that stores whether the project has been started yet: var UserProjects = sequelize.define('UserProjects', { started: Sequelize.BOOLEAN }) User.belongsToMany(Project, { through: UserProjects }) Project.belongsToMany(User, { through: UserProjects }) jan.addProject(homework, { started: false }) // The homework project is not started yet jan.setProjects([makedinner, doshopping], { started: true}) // Both shopping and dinner has been started If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model: p1.UserProjects = { started: true } user.setProjects([p1, p2], {started: false}) // The default value is false, but p1 overrides that. Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model. user.getProjects().then(function (projects) { var p1 = projects[0] p1.UserProjects.started // Is this project started yet? }) Params: Name Type Description target Model [options] object [options.hooks=false] boolean Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if User.hasOne(Profile, {onDelete: 'cascade', hooks:true}), the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks [options.through] Model | string | object The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it. [options.through.model] Model The model used to join both sides of the N:M association. [options.through.scope] object A key/value set that will be used for association create and find defaults on the through model. (Remember to add the attributes to the through model) [options.through.unique=true] boolean If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes) [options.as] string | object The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with plural and singular keys. See also the name option passed to sequelize.define. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target [options.foreignKey] string | object The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of source + primary key of source [options.otherKey] string | object The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see Sequelize.define for syntax). When using an object, you can add a name property to set the name of the column. Defaults to the name of target + primary key of target [options.scope] object A key/value set that will be used for association create and find defaults on the target. (sqlite not supported for N:M) [options.timestamps=sequelize.options.timestamps] boolean Should the join model have timestamps [options.onDelete='SETNULL | CASCADE'] string Cascade if this is a n:m, and set null if it is a 1:m [options.onUpdate='CASCADE'] string [options.constraints=true] boolean Should on update and on delete constraints be enabled on the foreign key. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/associations/belongs-to.html":{"url":"api/associations/belongs-to.html","title":"belongsTo","keywords":"","body":" Mixin BelongsTo View code One-to-one association In the API reference below, replace Assocation with the actual name of your association, e.g. for User.belongsTo(Project) the getter will be user.getProject(). getAssociation([options]) -> Promise. View code Get the associated instance. Params: Name Type Description [options] Object [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false. [options.schema] String Apply a schema on the related model setAssociation([newAssociation], [options]) -> Promise View code Set the associated model. Params: Name Type Description [newAssociation] Instance | String | Number An instance or the primary key of an instance to associate with this. Pass null or undefined to remove the association. [options] Object Options passed to this.save [options.save=true] Boolean Skip saving this after setting the foreign key if false. createAssociation([values], [options]) -> Promise View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create and setAssociation. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/associations/belongs-to-many.html":{"url":"api/associations/belongs-to-many.html","title":"belongsToMany","keywords":"","body":" Mixin BelongsToMany View code Many-to-many association with a join table. When the join table has additional attributes, these can be passed in the options object: UserProject = sequelize.define('user_project', { role: Sequelize.STRING }); User.belongsToMany(Project, { through: UserProject }); Project.belongsToMany(User, { through: UserProject }); // through is required! user.addProject(project, { role: 'manager', transaction: t }); All methods allow you to pass either a persisted instance, its primary key, or a mixture: Project.create({ id: 11 }).then(function (project) { user.addProjects([project, 12]); }); In the API reference below, replace Assocation(s) with the actual name of your association, e.g. for User.belongsToMany(Project) the getter will be user.getProjects(). getAssociations([options]) -> Promise.> View code Get everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model setAssociations([newAssociations], [options]) -> Promise View code Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated. Params: Name Type Description [newAssociations] Array. An array of instances or primary key of instances to associate with this. Pass null or undefined to remove all associations. [options] Object Options passed to through.findAll, bulkCreate, update and destroy. Can also hold additional attributes for the join table [options.validate] Object Run validation for the join model addAssociations([newAssociations], [options]) -> Promise View code Associate several instances with this. Params: Name Type Description [newAssociations] Array. An array of instances or primary key of instances to associate with this. [options] Object Options passed to through.findAll, bulkCreate and update. Can also hold additional attributes for the join table. [options.validate] Object Run validation for the join model. addAssociation([newAssociation], [options]) -> Promise View code Associate one instance with this. Params: Name Type Description [newAssociation] Instance | String | Number An instance or primary key of instance to associate with this. [options] Object Options passed to through.findAll, bulkCreate and update. Can also hold additional attributes for the join table. [options.validate] Object Run validation for the join model. createAssociation([values], [options]) -> Promise View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to create and add. Can also hold additional attributes for the join table removeAssociation([oldAssociated], [options]) -> Promise View code Un-associate the instance. Params: Name Type Description [oldAssociated] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to through.destroy removeAssociations([oldAssociated], [options]) -> Promise View code Un-associate several instances. Params: Name Type Description [oldAssociated] Array. Can be an array of instances or their primary keys [options] Object Options passed to through.destroy hasAssociation([instance], [options]) -> Promise View code Check if an instance is associated with this. Params: Name Type Description [instance] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to getAssociations hasAssociations([instances], [options]) -> Promise View code Check if all instances are associated with this. Params: Name Type Description [instances] Array. Can be an array of instances or their primary keys [options] Object Options passed to getAssociations countAssociations([options]) -> Promise. View code Count everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/associations/has-one.html":{"url":"api/associations/has-one.html","title":"hasOne","keywords":"","body":" Mixin HasOne View code One-to-one association In the API reference below, replace Association with the actual name of your association, e.g. for User.hasOne(Project) the getter will be user.getProject(). This is almost the same as belongsTo with one exception. The foreign key will be defined on the target model. getAssociation([options]) -> Promise. View code Get the associated instance. Params: Name Type Description [options] Object [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model setAssociation([newAssociation], [options]) -> Promise View code Set the associated model. Params: Name Type Description [newAssociation] Instance | String | Number An instance or the primary key of an instance to associate with this. Pass null or undefined to remove the association. [options] Object Options passed to getAssociation and target.save createAssociation([values], [options]) -> Promise View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create and setAssociation. This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/associations/has-many.html":{"url":"api/associations/has-many.html","title":"hasMany","keywords":"","body":" Mixin HasMany View code One-to-many association In the API reference below, replace Association(s) with the actual name of your association, e.g. for User.hasMany(Project) the getter will be user.getProjects(). getAssociations([options]) -> Promise.> View code Get everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false [options.schema] String Apply a schema on the related model setAssociations([newAssociations], [options]) -> Promise View code Set the associated models by passing an array of instances or their primary keys. Everything that is not in the passed array will be un-associated Params: Name Type Description [newAssociations] Array. An array of instances or primary key of instances to associate with this. Pass null or undefined to remove all associations. [options] Object Options passed to target.findAll and update. [options.validate] Object Run validation for the join model addAssociations([newAssociations], [options]) -> Promise View code Associate several instances with this. Params: Name Type Description [newAssociations] Array. An array of instances or primary key of instances to associate with this. [options] Object Options passed to target.update. [options.validate] Object Run validation for the join model. addAssociation([newAssociation], [options]) -> Promise View code Associate one instance with this. Params: Name Type Description [newAssociation] Instance | String | Number An instance or primary key of instance to associate with this. [options] Object Options passed to target.update. [options.validate] Object Run validation for the join model. createAssociation([values], [options]) -> Promise View code Create a new instance of the associated model and associate it with this. Params: Name Type Description [values] Object [options] Object Options passed to target.create. removeAssociation([oldAssociated], [options]) -> Promise View code Un-associate the instance. Params: Name Type Description [oldAssociated] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to target.update removeAssociations([oldAssociatedArray], [options]) -> Promise View code Un-associate several instances. Params: Name Type Description [oldAssociatedArray] Array. Can be an array of instances or their primary keys [options] Object Options passed to through.destroy hasAssociation([instance], [options]) -> Promise View code Check if an instance is associated with this. Params: Name Type Description [instance] Instance | String | Number Can be an Instance or its primary key [options] Object Options passed to getAssociations hasAssociations([instances], [options]) -> Promise View code Check if all instances are associated with this. Params: Name Type Description [instances] Array. Can be an array of instances or their primary keys [options] Object Options passed to getAssociations countAssociations([options]) -> Promise. View code Count everything currently associated with this, using an optional where clause. Params: Name Type Description [options] Object [options.where] Object An optional where clause to limit the associated models [options.scope] String | Boolean Apply a scope on the related model, or remove its default scope by passing false This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/hooks.html":{"url":"api/hooks.html","title":"Hooks","keywords":"","body":" Mixin Hooks View code Hooks are function that are called before and after (bulk-) creation/updating/deletion and validation. Hooks can be added to you models in three ways: By specifying them as options in sequelize.define By calling hook() with a string and your hook handler function By calling the function with the same name as the hook you want // Method 1 sequelize.define(name, { attributes }, { hooks: { beforeBulkCreate: function () { // can be a single function }, beforeValidate: [ function () {}, function() {} // Or an array of several ] } }) // Method 2 Model.hook('afterDestroy', function () {}) // Method 3 Model.afterBulkUpdate(function () {}) See: Sequelize#define addHook(hooktype, [name], fn) View code Add a hook to the model Params: Name Type Description hooktype String [name] String Provide a name for the hook function. It can be used to remove the hook later or to order hooks based on some sort of priority system in the future. fn Function The hook function Aliases: hook removeHook(hookType, name) View code Remove hook from the model Params: Name Type Description hookType String name String hasHook(hookType) View code Check whether the mode has any hooks of this type Params: Name Type Description hookType String Aliases: hasHooks beforeValidate(name, fn) View code A hook that is run before validation Params: Name Type Description name String fn Function A callback function that is called with instance, options afterValidate(name, fn) View code A hook that is run after validation Params: Name Type Description name String fn Function A callback function that is called with instance, options beforeCreate(name, fn) View code A hook that is run before creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options afterCreate(name, fn) View code A hook that is run after creating a single instance Params: Name Type Description name String fn Function A callback function that is called with attributes, options beforeDestroy(name, fn) View code A hook that is run before destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options Aliases: beforeDelete afterDestroy(name, fn) View code A hook that is run after destroying a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options Aliases: afterDelete beforeRestore(name, fn) View code A hook that is run before restoring a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options afterRestore(name, fn) View code A hook that is run after restoring a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options beforeUpdate(name, fn) View code A hook that is run before updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options afterUpdate(name, fn) View code A hook that is run after updating a single instance Params: Name Type Description name String fn Function A callback function that is called with instance, options beforeBulkCreate(name, fn) View code A hook that is run before creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options afterBulkCreate(name, fn) View code A hook that is run after creating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with instances, options beforeBulkDestroy(name, fn) View code A hook that is run before destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options Aliases: beforeBulkDelete afterBulkDestroy(name, fn) View code A hook that is run after destroying instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options Aliases: afterBulkDelete beforeBulkRestore(name, fn) View code A hook that is run before restoring instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options afterBulkRestore(name, fn) View code A hook that is run after restoring instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options beforeBulkUpdate(name, fn) View code A hook that is run before updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options afterBulkUpdate(name, fn) View code A hook that is run after updating instances in bulk Params: Name Type Description name String fn Function A callback function that is called with options beforeFind(name, fn) View code A hook that is run before a find (select) query Params: Name Type Description name String fn Function A callback function that is called with options beforeFindAfterExpandIncludeAll(name, fn) View code A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded Params: Name Type Description name String fn Function A callback function that is called with options beforeFindAfterOptions(name, fn) View code A hook that is run before a find (select) query, after all option parsing is complete Params: Name Type Description name String fn Function A callback function that is called with options afterFind(name, fn) View code A hook that is run after a find (select) query Params: Name Type Description name String fn Function A callback function that is called with instance(s), options beforeDefine(name, fn) View code A hook that is run before a define call Params: Name Type Description name String fn Function A callback function that is called with attributes, options afterDefine(name, fn) View code A hook that is run after a define call Params: Name Type Description name String fn Function A callback function that is called with factory beforeInit(name, fn) View code A hook that is run before Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with config, options afterInit(name, fn) View code A hook that is run after Sequelize() call Params: Name Type Description name String fn Function A callback function that is called with sequelize beforeSync(name, fn) View code A hook that is run before Model.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to Model.sync afterSync(name, fn) View code A hook that is run after Model.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to Model.sync beforeBulkSync(name, fn) View code A hook that is run before sequelize.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to sequelize.sync afterBulkSync View code A hook that is run after sequelize.sync call Params: Name Type Description name String fn Function A callback function that is called with options passed to sequelize.sync This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "},"api/transaction.html":{"url":"api/transaction.html","title":"Transaction","keywords":"","body":" Class Transaction View code The transaction object is used to identify a running transaction. It is created by calling Sequelize.transaction(). To run a query under a transaction, you should pass the transaction in the options object. Params: Name Type Description sequelize Sequelize A configured sequelize Instance options Object An object with options options.autocommit=true Boolean Sets the autocommit property of the transaction. options.type=true String Sets the type of the transaction. options.isolationLevel=true String Sets the isolation level of the transaction. options.deferrable String Sets the constraints to be deferred or immediately checked. TYPES View code Types can be set per-transaction by passing options.type to sequelize.transaction. Default to DEFERRED but you can override the default type by passing options.transactionType in new Sequelize. Sqlite only. The possible types to use when starting a transaction: { DEFERRED: \"DEFERRED\", IMMEDIATE: \"IMMEDIATE\", EXCLUSIVE: \"EXCLUSIVE\" } Pass in the desired level as the first argument: return sequelize.transaction({ type: Sequelize.Transaction.EXCLUSIVE }, function (t) { // your transactions }).then(function(result) { // transaction has been committed. Do something after the commit if required. }).catch(function(err) { // do something with the err. }); ISOLATION_LEVELS View code Isolations levels can be set per-transaction by passing options.isolationLevel to sequelize.transaction. Default to REPEATABLE_READ but you can override the default isolation level by passing options.isolationLevel in new Sequelize. The possible isolations levels to use when starting a transaction: { READ_UNCOMMITTED: \"READ UNCOMMITTED\", READ_COMMITTED: \"READ COMMITTED\", REPEATABLE_READ: \"REPEATABLE READ\", SERIALIZABLE: \"SERIALIZABLE\" } Pass in the desired level as the first argument: return sequelize.transaction({ isolationLevel: Sequelize.Transaction.SERIALIZABLE }, function (t) { // your transactions }).then(function(result) { // transaction has been committed. Do something after the commit if required. }).catch(function(err) { // do something with the err. }); LOCK View code Possible options for row locking. Used in conjunction with find calls: t1 // is a transaction t1.LOCK.UPDATE, t1.LOCK.SHARE, t1.LOCK.KEY_SHARE, // Postgres 9.3+ only t1.LOCK.NO_KEY_UPDATE // Postgres 9.3+ only Usage: t1 // is a transaction Model.findAll({ where: ..., transaction: t1, lock: t1.LOCK... }); Postgres also supports specific locks while eager loading by using OF: UserModel.findAll({ where: ..., include: [TaskModel, ...], transaction: t1, lock: { level: t1.LOCK..., of: UserModel } }); UserModel will be locked but TaskModel won't! commit() -> Promise View code Commit the transaction rollback() -> Promise View code Rollback (abort) the transaction This document is automatically generated based on source code comments. Please do not edit it directly, as your changes will be ignored. Please write on IRC, open an issue or a create a pull request if you feel something can be improved. For help on how to write source code documentation see JSDoc and dox "}}